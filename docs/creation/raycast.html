<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8" />
        <title>SAASF - Raycast</title>
        <link href="..//styles/style.css" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&amp;display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet">

    </head>

    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
    <img alt="Logo de SAASF" src="..//images/aster_system_logo.png">
</header>
        <div id="main_div">
            <h1>De la 3D avec le Raycast</h1>
                En général, le rendu d'un jeu vidéo 3D se fait via différentes APIs graphiques, comme OpenGL ou Direct3D.
Cependant, ces APIs nécessitent une accélération matériel, via la carte graphique.
En effet, elle demande beaucoup de performances, et sont presque irréalisables sans cela.
Cependant, comment faire pour afficher de la 3D, sans accélération matérielle ?
La technique la plus efficace, utilisée depuis les années 90, est le Raycast.
                <div class="left_arrow_right_text">
                    
                        <div class="left_arrow_right_text_child">
                            <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="..//images/arrow.png">
                            <h2 class="left_arrow_right_text_title">
                                Commencer par... de la 2D
                            </h2>
                            <div class="left_arrow_right_text_text">
                                <h3>Projeter de la 2D</h3>
<p>Nous voulons faire un jeu 3D.
Alors, pourquoi donc commencer par de la 2D ?
Dans le cas du Raycast, c'est l'un des meilleurs moyens pour comprendre l'idée géénrale de la technique.
En effet, le Raycast est, en réalité, une projection en 3D d'un environnement 2D.
La première chose à faire est de définire cet environnement.</p>
<p>Pour commencer, nous allons créer une simple map en 2D.
Pour des raisons de clareté, nous allons aussi définir un moyen d'afficher cette map de dessus (donc, en 2D pur).
Commençon simplement, en disant que les cases blanches sont du vide et les cases rouges des murs.
Travaillons sur cette map :</p>
<img alt="Map 2D" src="../images/raycast/map_2d.png" style="max-height:300px">
<p>Notre problème ici, pour le rendu 3D,
est de savoir comment afficher les éléments de cette map en 3D,
avec des performances tolérables.
Avec les APIs modernes,
la puissance de calcul est suffisante pour afficher tous les éléments 1 par 1,
et calculer en temps réel lesquels afficher et ne pas afficher.
Dans notre cas, il faudrait générer 22 cases contenant des murs.
Sans accélération matérielle,
cette étape devient vite très demandante en ressources,
et les performances peuvent devenir catastrophique (surtout sur une map plus grande).
Il faut donc agir sur l'algorithme pour éviter ce problème.</p>
<p>La transformation que nous allons faire va nous permettre d'économiser des ressources,
sans pour autant donner un résultat affreux.
L'idée ici est de n'afficher que le strict nécessaire au rendu 3D,
et d'éviter d'en afficher trop.
Cependant, le problème est de savoir quels objets afficher et lesquels ne pas afficher.
C'est la que le Raycast rentre en jeu,
puisqu'il s'agit d'une technique permettant de faire cela.
Nous allons voir quels objets doivent être affichés via la technique de lancer de rayons,
ou, traduit en anglais, "Raycast".</p>
<h3>Le lancer de rayons</h3>
<p>L'idée ici va être de détecter tous les objets à afficher (donc, devant la caméra) grâce à la technique des rayons.
Pour cela, nous avons besoin de la map, de la position caméra et de la rotation de la caméra.
Avec ces données, nous allons tracer un rayon, qui va nous permettre de savoir quels objets afficher.
En marquant la caméra par un point bleu clair et le rayon par une ligne bleu foncé, le lancer ressemble à ça :</p>
<img alt="Lancer de rayons" src="../images/raycast/ray_2d.png" style="max-height: 300px;">
<p>Avec ce simple rayon, nous pouvons déjà savoir que le mur touché devra être afficher.
Bien évidemment, un seul mur ne suffit pas.
En agrandissant le nombre de rayons, et en les rapprochant,
nous pouvons définir tout un point de vue,
qui représente toute la partie bleu foncé sur cette image :</p>
<img alt="Plus de rayons" src="../images/raycast/rays_2d.png" style="max-height: 300px;">
<p>Le nombre de rayon et leur espacement dépent des besoins du jeu / du joueurs,
des capacités de l'ordinateur du joueur, de la taille de la map...
Dés que vous avez tous les objets nécessaires, vous pouvez les afficher sur l'écran.
Cette étape peut dépendre de beaucoup de choses, et nous en verrons quelques exemples juste après.
Mais avant, mettons précisément au point notre algorithme de lancer de rayon.</p>
                            </div>
                        </div>
                    
                        <div class="left_arrow_right_text_child">
                            <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="..//images/arrow.png">
                            <h2 class="left_arrow_right_text_title">
                                Créer l'algorithme Raycast
                            </h2>
                            <div class="left_arrow_right_text_text">
                                <h3>Les bases de l'algorithme</h3>
<p>Pour que notre algorithme marche, nous allons devoir poser quelques bases.
Premièrement, la map du jeu sera contenu dans une liste à deux dimensions.
La première dimension représente la coordonnée Y de la case, et la deuxième dimension la coordonnée X de la case.
Définissons ces données comme statiques dans le temps.</p>
<p>L'algorithme aura besoin de deux entrées principales : les coordonnées de la caméra, et l'angle de la caméra.
Par définition, l'angle de la caméra représente le "devant" de la caméra, vers où projeter le rayon.
Pour des soucis de simplicité mathématique, le départ de l'angle représente la droite partant vers la droite de la caméra.
L'algorithme sortira le point de collision entre le premier mur trouvé (ou le fond de la map si aucun mur n'est trouvé) et le rayon.
Si on résume, l'algorithme aura comme donnée de départ :</p>
<img alt="Données de départ" src="../images/raycast/input.png" style="max-width:300px;">
<h3>Simuler l'avancée du rayon</h3>
<p>Pour simuler l'avancée du rayon, nous allons utiliser les propriétés de notre map cadriller.
En effet, à chaque fois que notre rayon va avancer d'une case horizontale, il va avancer d'un certain nombre de cases verticals, que nous appellerons horizontal_ratio.
Et, vice versa, à chaque fois que la rayon va avancer d'une case verticale,
il va avancer d'un certain nombre de cases horizontales (l'inverse de horizontal_ratio), que nous appellerons vertical_ratio.
Grâce à cette propriété, on peut connaître les zones de collisions avec chaque cases devant le rayon, en avançant cases par cases.
Pour n'en louper aucune, il faut avancer horizontalement et verticalement aux cases, en prenant en compte que l'avancer peut se faire à sens arrière, selon les orientations du rayon.
Les orientations en question seront nommées horizontal_advance et vertical_advance.
Nous devrons aussi prendre en compte que la position de départ du rayon n'est pas un nombre entier, mais rationnel, et qu'il faudra passer à la case précédente / suivante pour ne pas décaler le rayon.
Si une case contient un mur, on arrête la progression du rayon : il a heurté un mur.</p>
<p>Parler, c'est bien.
Cependant, pour avoir tous ses résultats, il va falloir faire un peu de mathématiques.
Pour calculer les ratios, il nous faut la valeur de la pente du rayon tracé par l'angle avant pour une case horizontal / vertical parcourue.
Pour effectuer ce calcul, nous allons utiliser un peu de <a href="https://fr.wikipedia.org/wiki/Trigonom%C3%A9trie" target="_blank">trigonométrie</a>, et, plus précisément, nous allons utiliser le <a href="https://fr.wikipedia.org/wiki/Cercle_trigonom%C3%A9trique" target="_blank">cercle trigonométrique</a>.
En effet, les propriétés de ce cercle nous disent que nous pouvons obtenir les valeurs précises de la pente du rayon, horizontalement avec le cosinus et verticalement avec le sinus.
Pour des raisons de simplicité, nous allons prendre les valeurs absolues dans les calculs.
Grâce à cette propriété, une simple division suffit à calculer les ratios, et nous obtenons les valeurs nécessaires :</p>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mstyle displaystyle="true">
    <mrow class="MJX-TeXAtom-ORD">
      <mi>horizontal_ratio</mi>
      <mo>=</mo>
      <mfrac>
        <mrow>
          <mi>|sin(angle)|</mi>
        </mrow>
        <mrow>
          <mi>|cos(angle)|</mi>
        </mrow>
      </mfrac>
      </mrow>
    </mstyle>
</math></br></br>
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mstyle displaystyle="true">
    <mrow class="MJX-TeXAtom-ORD">
      <mi>vertical_ratio</mi>
      <mo>=</mo>
      <mfrac>
        <mrow>
          <mi>1</mi>
        </mrow>
        <mrow>
          <mi>horizontal_ratio</mi>
        </mrow>
      </mfrac>
    </mrow>
  </mstyle>
</math>
<p>Maintenant que cela est fait, calculons horizontal_advance et vertical_advance.
Pour ces deux variables, deux valeurs sont possibles : 1 ou -1.
Si l'angle pointe vers l'avant (donc, que la valeur du cosinus de l'angle est positive), l'avancement horizontal est positif.
Sinon, elle est négative.
C'est la même chose pour l'avancement vertical, avec la valeur du sinus cette fois ci.</p>
                            </div>
                        </div>
                    
                </div>
        </div>
        <footer>
    <h1>Plus d'informations</h1>
    <div class="open-sans-regular">
        SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.<br>
        Le site web est disponible sur Github, <a href="https://github.com/aster-system/saasf" target="_blank">dans ce repositorie</a>.<br>
        <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
        <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par
        <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
        </span>
     </div>
</footer>
    </body>
</html>