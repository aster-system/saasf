<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - OpenGL en C++</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <a href="../../index.html">
                <img alt="Logo de SAASF" src="../../images/aster_system_logo.png" style="max-height:150px;">
            </a>
        </header>
        <div id="main_div">
            <h1>
                Utiliser OpenGL en C++
            </h1>
            <div>
                Pour l'instant, les seules interactions que nous pouvons avoir avec notre programme C++ sont les fichiers et la console.
                Nous allons ici apprendre à augmenter les possibilités d'interactions avec le programme, grâce à une API très connue : <a href="https://www.khronos.org/opengl/" target="_blank">OpenGL</a>.
                Pour rappel, nous avons déjà fait un cours sur OpenGL, <a href="../../creations/opengl.html">juste ici</a>.
                Pour des raisons de temps, nous allons considérer tout ce qui a été vu sur ce cours comme acquis.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Créez votre fenêtre OpenGL
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <h3>a. Mettre en place votre environnement</h3>
                        <div>
                            <p>
                                Disons le, <u>OpenGL est une librairie assez complexe à utiliser</u>.
                                Pour y accéder, chaque systèmes d'exploitations offrent nativement différents outils pour y accéder.
                                Cependant, pour gagner du temps, <span class="important">nous allons utiliser des librairies C++ qui permettent d'utiliser simplement tout ça</span>.
                                Nous allons utiliser 3 librairies : <a href="https://www.glfw.org/" target="_blank">GLFW</a>, <a href="https://glad.dav1d.de/" target="_blank">Glad</a> et <a href="https://github.com/g-truc/glm" target="_blank">GLM</a>.
                            </p>
                            <p>
                                <span class="important">GLFW va être un moyen simple d'utiliser un contexte OpenGL</span>.
                                En effet, <u>elle est pleine de fonctions très utiles pour travailler avec OpenGL</u>.
                                Elle a l'avantage d'être cross-platforme et en libre accès.
                                Pour installer GLFW, <a href="https://www.glfw.org/download.html" target="_blank">rendez vous sur cette page</a>.
                                Vous pouvez télécharger le code source et le compiler vous même, ou utiliser du code pré-compilé.
                                Pour rappel, nous avons déjà traité de l'utilisation de librairies de ce genre, <a href="../../astersystemelearn/cpp_lessons/cpp_bases.html" target="_blank">dans ce cours là</a>.
                                Vous devrez théoriquement avoir accès a un DLL, deux fichiers librairies, et un ensemble de headers.
                            </p>
                            <p>
                                <span class="important">Glad va avoir pour tâche de rendre notre code OpenGL cross-plateforme</span>.
                                En effet, comme nous l'avons vu, chaque plateforme propose sa propre implémentation d'OpenGL.
                                <u>Glad réuni tous les types possibles, et les rend accessibles selon la plateforme actuelle</u> grâce au système de <a href="../../astersystemelearn/cpp_lessons/cpp_templates.html">template</a>.
                                Pour installer Glad, <a href="https://glad.dav1d.de/" target="_blank">rendez vous sur cette page</a>.
                                Elle vous demandera pas mal de configuration pour le fichier environnement généré.
                                <span class="important">Comme langage, sélectionnez "C/C++"". Comme spécification, sélectionnez "OpenGL". Comem API, sélectionnez "Version 3.3" dans "gl" (Comme sur notre cours d'OpenGL). Comme "Profile", choisissez "Core".</span>
                                Cependant, à l'inverse de GLFW, Glad ne propose pas de fichiers pré-compilés.
                                <u>Le site vous proposera un dossier de headers, ainsi qu'un fichier "glad.c", à ajouter aux fichiers compilés de votre code</u>.
                            </p>
                            <p>
                                Finalement, <span class="important">GLM va nous apporter un ensemble d'outils mathématiques, très importants pour OpenGL</span>.
                                En effet, <u>les mathématiques nécessaires seront très avancés ici</u>.
                                Heuresement, GLM en propose une partie.
                                Pour installer GLM, <a href="https://github.com/g-truc/glm" target="_blank">rendez vous sur cette page</a>.
                                Vous y trouverez l'ensemble du projet GLM.
                                <span class="important">Vous aurez besoin de tous les headers présents dans le dossier "glm"</span>.
                                Dans cette librairie, il n'y a que des headers.
                            </p>
                            <p>
                                Dés que tout cela est installé, vous pouvez créer votre projet pour commencer à travailler avec OpenGL.
                            </p>
                        </div>
                        <h3>b. Créer votre première fenêtre</h3>
                        <div>
                            <p>
                                Pour créer notre première fenêtre avec OpenGL, <span class="important">il va falloir commencer à écrire le code permettant de configurer OpenGL</span>.
                                <u>Nous vous conseillons grandement de bien le structurer, pour pouvoir l'utiliser de manière plus simple</u>.
                                Cependant, si vous avez la flemme (déconseillé), vous pouvez tout mettre directement dans la fonction "main" de votre code.
                                Avant tout, <u>initialisons GLFW, avec quelques simples lignes de code</u>.
                                <div class="code_sample">
                                    // Initialisation de GLFW</br>
                                    glfwInit();</br>
                                    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</br>
                                    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</br>
                                    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
                                </div>
                                Ces fonctions sont assez claires : "glfwInit()" initialise GLFW, et <a href="https://www.glfw.org/docs/3.3/group__window.html" target="_blank">"glfwWindowHint()"</a> permet de configurer certaines valeurs de GLFW, grâce à deux paramètres : la configuration à modifier, et sa nouvelle valeur.
                                Dans ce cas, nous configurons la version (majeure et mineure) d'OpenGL, en 3.3 ici, puis nous indiquons à GLFW que nous utiliser la version "core" d'OpenGL (téléchargée plus haut via Glad).
                                En suite, <u>créeons notre contexte OpenGL</u>.
                                <div class="code_sample">
                                    // Création du contexte OpenGL</br>
                                    GLFWwindow* window = glfwCreateWindow(500, 500, "Mon programme OpenGL", NULL, NULL);</br>
                                    if (window == NULL) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwTerminate();</br>
                                    }</br>
                                    glfwMakeContextCurrent(window);
                                </div>
                                Ces fonctions restent aussi assez claires : "glfwCreateWindow()" crée la fenêtre pour OpenGL et la retourne sous forme de pointeur vers un objet <a href="https://www.glfw.org/docs/latest/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242" target="_blank">"GLFWwindow"</a>, la condition vérifie si la création a bien eu lieu, et "glfwMakeContextCurrent()" indique à GLFW (et, indirectement, à l'OS du PC) que le contexte actuel du programme est le contexte passé en paramètre.
                                Nous pouvons constater la fonction <a href="https://www.glfw.org/docs/3.3/group__init.html#gaaae48c0a18607ea4a4ba951d939f0901" target="_blank">"glfwTerminate()"</a> dans la condition, qui a pour tâche de décharger GLFW pour le programme (si il doit s'arrêter).
                                Attardons nous sur <a href="https://www.glfw.org/docs/latest/group__window.html#ga3555a418df92ad53f917597fe2f64aeb" target="_blank">"glfwCreateWindow()"</a>.
                                Elle prend beaucoup de paramètres.
                                <u>Les deux premiers représentent la largeur et la hauteur de la fenêtre</u>.
                                Le troisième représente le titre affiché en haut à gauche de la fenêtre.
                                Le quatrième représente un pointeur vers un objet <a href="https://www.glfw.org/docs/latest/group__monitor.html#ga8d9efd1cde9426692c73fe40437d0ae3" target="_blank">GLFWmonitor</a>.
                                Si ce pointeur est utilisé, alors le programme va être en plein écran sur l'écran demandé.
                                Sinon (comme maintenant), il ne sera pas en plein écran.
                                Le cinquième permet de lier une autre fenêtre déjà crée avec celle-ci pour un partage de ressources entre fenêtre si besoin (nous n'en aurons pas besoin ici).
                                <span class="important">Si la fenêtre ne peut pas être générée, la fonction renvoie un pointeur nul, et la condition d'erreur est activée, affichant un mesage d'erreur et déchargeant GLFW</span>.
                                En suite, <u>chargeons Glad</u>.
                                <div class="code_sample">
                                    // Chargement de Glad</br>
                                    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwTerminate();</br>
                                    }
                                </div>
                                <span class="important">Glad est chargé dans la fonction "gladLoadGLLoader()", qui renvoie "true" si le chargement est bon, ou "false" si il n'est pas bon</span>.
                                Si il ne l'est pas, la condition d'erreur est activée, affichant un mesage d'erreur et déchargeant GLFW.
                                Cette fonction est assez complexe : elle prend la fonction <a href="https://www.glfw.org/docs/latest/group__context.html#ga35f1837e6f666781842483937612f163" target="_blank">"glfwGetProcAddress()"</a> de GLFW en paramètre, retournant un pointeur vers la bonne API OpenGL utilisée par le contexte actuel.
                                N'hésitez pas à aller voir la documentation si cette fonction vous intéresse.
                                Dés que tout cela est fait, <span class="important">la partie configuration est terminée</span>.
                            </p>
                            <p>
                                Maintenant, <span class="important">nous allons implémenter la boucle qui va permettre à notre programme de tenir dans le temps</span>.
                                Tout aura lieu dans une boucle, qui s'arrêtera en même temps que le programme.
                                La boucle aura cette allure :
                                <div class="code_sample">
                                    // Boucle de temps</br>
                                    while(!glfwWindowShouldClose(window)) {</br></br>

                                    }</br>
                                    glfwTerminate();
                                </div>
                                Ici, <a href="https://www.glfw.org/docs/latest/group__context.html#ga35f1837e6f666781842483937612f163" target="_blank">"glfwWindowShouldClose()"</a> vérifiera si la fenêtre doit se fermer.
                                Après avoir fermer la fenêtre, on décharge GLFW avec "glfwTerminate()".
                                <u>Si nous lançons le programme comme ça, rien ne va se passer, et le programme ne pourra même pas se fermer tout seul</u>.
                                Pour utiliser la fenêtre, nous allons modifier l'intérieur de la boucle.
                                <div class="code_sample">
                                    // Boucle de temps</br>
                                    while(!glfwWindowShouldClose(window)) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Préparer l'affichage OpenGL</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glClearColor(0, 0.4, 0.9, 1.0);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT);</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Met à jour OpenGL</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwSwapBuffers(window);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwPollEvents();</br>
                                    }</br>
                                    glfwTerminate();
                                </div>
                                Ce code rend la page tout à fait utilisable : décrivons le étape par étape.
                                <span class="important"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClear.xhtml" target="_blank">"glClear()"</a> permet de remettre les zones mémoires générées auparavant d'OpenGL à 0 (ou ne fait rien si aucune zone mémoire n'a été générée)</span>.
                                Comme ça, vous n'encombrez pas la mémoire de choses inutiles.
                                Ici, on passe en paramètre "GL_COLOR_BUFFER_BIT", pour n'effacer que la partie "couleur" d'OpenGL (l'ancienne zone d'affichage).
                                Il s'agit d'une fonction de base d'OpenGL (rendue utilisable par Glad).
                                Cependant, <u>OpenGL va remplir la nouvelle zone de mémoire d'affichage par une nouvelle couleur, spécifiée via la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearColor.xhtml" target="_blank">glClearColor()</a></u>.
                                Elle prend 4 paramètres : les valeurs RGBA de la couleur nécessaire (qui peuvent être des valeurs sur 255, ramenée à entre 0 et 1).
                                Ces valeurs doivent être entre 0 et 1.
                                Ici, il s'agit d'un bleu ciel (le même que la couleur d'arrière plan de la fenêtre nouvellement crée).
                                En suite, <span class="important">on demande à GLFW de confirmer l'affichage de la fenêtre, qui va être envoyée à la carte graphique avec <a href="https://www.glfw.org/docs/latest/group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14" target="_blank">glfwSwapBuffers()</a></span>.
                                Finalement, <u><a href="https://www.glfw.org/docs/latest/group__window.html#ga37bd57223967b4211d60ca1a0bf3c832" target="_blank">"glfwPollEvents()"</a> met à jour les évènements ayant eu lieu depuis le dernier appel de la fonction (clique de souris, entré clavier, fermeture de la fenêtre...)</u>.
                                Cet données seront par la suite accessible via des fonctions, que nous verrons plus tard.
                                <u>Maintenant que cette fenêtre est crée, commençons à la rendre utilisable</u>.
                            </p>
                            <img alt="Fenêtre OpenGL" src="../../images/cpp_opengl/window.png" style="max-height:300px;">
                        </div>
                        <h3>c. Créer des objets OpenGL</h3>
                        <div>
                            <p>
                                Pour pouvour utiliser pleinement OpenGL, <span class="important">nous allons créer des objets dans OpenGL</span>.
                                Comme nous l'avons vu dans la présentation d'OpenGL, <span class="important">les objets OpenGL sont utilisés via des VAOs, des VBOs et des shaders</span>.
                            </p>
                            <p>
                                <span class="important">Commençons par le plus simple : les VBOs</span>.
                                Pour des raisons de simplicité, nous mettrons l'entiereté des données d'un VBO dans une structure.
                                <div class="code_sample">
                                    // Structure pour un VBO</br>
                                    struct VBO {</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Id du VBO</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;unsigned int id;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Points dans le VBO</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;float&gt; points;</br>
                                    };
                                </div>
                                Nous l'étudierons plus précisément plus tard.
                                Pour passer des VBOs à OpenGL, <u>il vous faut une liste de points</u>.
                                Ici, notre liste sera dans le vecteur "points".
                                <span class="important">Pour commencer simplement, faisons un simple triangle</span> (pour rappel, OpenGL ne peut qu'afficher des triangles).
                                <div class="code_sample">
                                    // Création du VBO nécessaire</br>
                                    VBO triangle;</br></br>
                                    // Création d'un triangle</br>
                                    triangle.points.push_back(-0.5);triangle.points.push_back(-0.5);triangle.points.push_back(0);</br>
                                    triangle.points.push_back(0.5);triangle.points.push_back(-0.5);triangle.points.push_back(0);</br>
                                    triangle.points.push_back(0);triangle.points.push_back(0.5);triangle.points.push_back(0);
                                </div>
                                Dans une fenêtre OpenGL, les extrémités (gauche / droite, bas / haut) représentent les coordonnées -1 et 1.
                                Dés que cela est fait, <u>nous allons les passer à OpenGL</u>.
                                <div class="code_sample">
                                    // Attribution d'un espace mémoire pour le VBO</br>
                                    glGenBuffers(1, &triangle.id);</br></br>
                                    // Passage du VBO à OpenGL</br>
                                    glBindBuffer(GL_ARRAY_BUFFER, triangle.id);</br>
                                    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * triangle.points.size(), triangle.points.data(), GL_STATIC_DRAW);</br>
                                </div>
                                Premièrement, obtenons de la part d'OpenGL une partie de mémoire, via la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml" target="_blank">glGenBuffers()</a>.
                                Son premier paramètre représente le nombre d'objets OpenGL que nous allons crée (ici, qu'un seul VBO), et le deuxième représente une référence vers un nombre (unsigned int), qui aura une valeur que nous pourrons utiliser pour accéder à cet objet OpenGL.
                                En suite, nous indiquons à OpenGL que nous allons utiliser la partie de mémoire créée comme le VBO actuellement utilisé (GL_ARRAY_BUFFER) par OpenGL grâce à la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml" target="_blank">glGenBuffers()</a>.
                                Finalement, <u>nous envoyons dans cette partie de mémoire les données du VBO</u>.
                                Pour cela, nous utilisons la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml" target="_blank">glBufferData()</a>, permettant d'envoyer des données dans une zone de mémoire OpenGL.
                                Le premier paramètre représente l'endroit où envoyer les données (ici, le VBO actuellement utilisé, défini plus haut).
                                Le deuxième paramètre représente la taille en octet de données que nous allons passer à la mémoire.
                                Nous n'allons passer que des "float" (4 octets de mémoire), autant qu'il y en a dans le vecteur des points du triangle.
                                <u>Le troisième paramètre nous permet d'indiquer les données à passer à la mémoire</u>.
                                Elle prend en paramètre un pointeur vers un tableau de données C++.
                                Ici, nous lui passons un pointeur vers les données du vecteur sous forme de tableau, grâce à la méthode "data".
                                Finalement, le dernier paramètre représente la façon dont OpenGL doit écrire les données.
                                La méthode "GL_STATIC_DRAW" est la plus rapide à utiliser, mais sera plus longue à modifier dans le futur si besoin (nous ne le ferons pas ici).
                                Pour en finir, il nous faut ajouter un moyen de supprimer les données allouées par OpenGL à la mémoire.
                                <div class="code_sample">
                                    // Libère la mémoire allouée pour le VBO</br>
                                    glDeleteBuffers(1, &amp;triangle.id);
                                </div>
                                La fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml" target="_blank">glDeleteBuffers()</a> fonctionne de la même manière que "glGenBuffers()", vue plus haut.
                                Cette opération doit être effectuée après la boucle d'éxecution.
                                Maintenant, <span class="important">votre VBO est bien chargé dans la mémoire d'OpenGL</span>.
                            </p>
                            <p>
                                En suite, <span class="important">nous allons passer le shader vers OpenGL</span>.
                                Pour commencer, <u>il vous faudra vos deux shaders nécessaires : un vertex shader et un fragment shader</u>.
                                Nous allons simplement recopier une version simplifiée de ceux dans le cours d'introduction à OpenGL.
                                <div class="code_sample">
                                    // Vertex</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Données du VBO (vec3 représente un point 3D)</br>
                                    layout(location = 0) in vec3 pos; // Position du point P</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Calcul du point retourné par le shader</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;gl_Position = vec4(pos.xyz, 1.0);</br>
                                    }
                                </div>
                                <div class="code_sample">
                                    // Fragment</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Couleur sortie du shader</br>
                                    out vec4 FragColor;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp&nbsp;// Calcul de la couleur nécessaire, avec ici le rouge, ou RGBA(255, 0, 0, 255)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(1, 0, 0, 1);</br>
                                    }
                                </div>
                                <span class="important">Ce code utilise un langage très proche du C : <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_blank">GLSL</a></span>.
                                Comme en C, la fonction principale du programme est "main()", qui ne retourne rien.
                                <u>Le type vec3 correspond à un vecteur de 3 flottants et vec4 correspond à un vecteur de 4 flottants</u>.
                                Ici, le "#version 330 core" permet de spécifier la version d'OpenGL utilisé ici.
                                <u>Les variables définis avec "out" signifient que le shader retourne ces variables pour le prochain shader</u>.
                                "FragColor" représente la couleur pour le pixel traité par le shader.
                                Cependant, certaines variables sont directement incluses à OpenGL, comme "gl_Position", qui représente la position précise d'un point du VBO (que nous pouvons modifier pour bouger l'objet).
                                À l'inverse, <u>les variables définis avec "in" signifient que le shader reçoit ces variables depuis le dernier shader (ou depuis le VBO dans le cas du vertex shader)</u>.
                                Dans le vertex shader, "layout(location = x)" permet de dire à shader d'aller chercher une certains variable dans le VBO, acomme étant la "x ième" variable traitée pour un point du VBO.
                                Nous verrons comment utiliser ça précisement un peu après.
                                Plaçons ces codes dans des "std::string", que nous appellerons respectivement "vertex_shader" et "fragment_shader".
                                Ces codes vont être directement compilés par OpenGL.
                                <div class="code_sample">
                                    // Compilation du fragment shader</br>
                                    unsigned int fragment = glCreateShader(GL_FRAGMENT_SHADER);</br>
                                    char* current_shader = new char[fragment_shader.size()];</br>
                                    for(int i = 0;i&lt;fragment_shader.size();i++){current_shader[i]=fragment_shader[i];}</br>
                                    int shader_size = fragment_shader.size();</br>
                                    glShaderSource(fragment, 1, &amp;current_shader, &amp;shader_size);</br>
                                    glCompileShader(fragment); delete current_shader;</br></br>
                                    // Compilation du vertex shader</br>
                                    unsigned int vertex = glCreateShader(GL_VERTEX_SHADER);</br>
                                    current_shader = new char[vertex_shader.size()];</br>
                                    for(int i = 0;i&lt;vertex_shader.size();i++){current_shader[i]=vertex_shader[i];}</br>
                                    shader_size = vertex_shader.size();</br>
                                    glShaderSource(vertex, 1, &amp;current_shader, &amp;shader_size);</br>
                                    glCompileShader(vertex); delete current_shader;
                                </div>
                                Le code est quasiment le même pour les deux shaders.
                                Nous commençons par créer un simple shader (de type GL_FRAGMENT_SHADER ou GL_VERTEX_SHADER) grâce à la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" target="_blank">glCreateShader()</a>.
                                Elle retourne ensuite un ID, qui permettra d'accéder au shader nouvellement créé.
                                En suite, <u>nous spécifions au shader nouvellement créé le code qui le constitue, grâce à <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml" target="_blank">glShaderSource()</a></u>.
                                Cette fonction prend en premier paramètre le shader à traiter (via son ID).
                                Le deuxième paramètre permet de savoir combien de shaders vont être compilés (qu'un seul ici).
                                Le troisième paramètre est assez spécial.
                                <u>Il s'agit d'un pointeur VERS un pointeur VERS le contenu du shader, sous forme de tableau de caractère</u>.
                                C'est pour cela que nous le créeons dans un nouveau tableau de caractère, grâce à "current_shader" et à la boucle.
                                Finalement, le dernier paramètre prend un pointeur vers une variable contenant la taille du shader a compilé.
                                Dés que le shader est entièrement passé, <span class="important">il est compilé avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml" target="_blank">glCompileShader()</a></span>.
                                N'oubliez pas de supprimer le tableau de caracètre crée à la fin, pour ne pas perdre d'espace mémoire.
                                Dés que cela est fait, nous devons nous assurer que rien n'est arrivé pendant la compilation.
                                <div class="code_sample">
                                    // Vérifier le fragment shader</br>
                                    int  success = 0;</br>
                                    char infoLog[512];</br>
                                    glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);</br>
                                    if (!success) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glGetShaderInfoLog(fragment, 512, NULL, infoLog);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Erreur de compilation sur le fragment" &lt;&lt; std::endl &lt;&lt; infoLog &lt;&lt; std::endl;</br>
                                    }</br></br>
                                    // Vérifier le vertex shader</br>
                                    success = 0;</br>
                                    glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);</br>
                                    if (!success) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glGetShaderInfoLog(vertex, 512, NULL, infoLog);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Erreur de compilation sur le vertex shader" &lt;&lt; std::endl &lt;&lt; infoLog &lt;&lt; std::endl;</br>
                                    }
                                </div>
                                Ici, <a href="https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glGetShaderiv.xml" target="_blank">glGetShaderiv()</a> permet de récupérer une information sur le shader.
                                Le premier paramètre représente le shader à tester, le deuxième représente l'information à tester, et le troisième représente une référence vers un entier contenant la réponse de la fonction.
                                Si le shader n'a pas pu être compilé, <span class="important">on cherche ce qui ne va pas grâce à la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml" target="_blank">glGetShaderInfoLog()</a></span>.
                                Son premier paramètre représente le shader à tester, le deuxième représente la taille maximale des informations sorties par la fonction, la troisième représente un pointeur vers une variable contenant la taille réelle renvoyée et la quatrième représente l'endroit où écrire l'information.
                                Nous afficheons en suite cette erreur à l'écran.
                                Si tout cela fonctionne, alors nous pouvons finir de créer notre shader.
                                <div class="code_sample">
                                    // Génération du shader dans OpenGL</br>
                                    unsigned int shader_program = glCreateProgram();</br>
                                    glAttachShader(shader_program, vertex);</br>
                                    glAttachShader(shader_program, fragment);</br>
                                    glLinkProgram(shader_program);
                                </div>
                                Nous commençons par créer un programme entier de shader via <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml" target="_blank">glCreateProgram()</a>, encore une fois sous la forme de "unsigned int".
                                Après, <span class="important">nous attachons les programmes compilés à ce programme avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml" target="_blank">glAttachShader()</a></span>.
                                Finalement, vous liez le programme final avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml" target="_blank">glLinkProgram()</a>, et le tour est joué.
                                Il reste trois dernière étapes avant d'en finir.
                                <div class="code_sample">
                                    // Vérifier le shader final</br>
                                    success = 0;</br>
                                    glGetProgramiv(shader_program, GL_LINK_STATUS, &success);</br>
                                    if (!success) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glGetProgramInfoLog(shader_program, 512, NULL, infoLog);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Erreur de compilation" &lt;&lt; infoLog &lt;&lt; std::endl;</br>
                                    }</br></br>
                                    // Supression des ressources inutiles</br>
                                    glDeleteShader(vertex);</br>
                                    glDeleteShader(fragment);
                                </div>
                                Nous commençons par une dernière vérification du shader, puis nous supprimons les shaders compilé (le nouveau programme de shader en aura fait une copie).
                                Dés que tout cela est fait, il ne nous reste plus qu'à préciser au shaders les paramètres d'entrées du vertex shader.
                                <div class="code_sample">
                                    // Shader actuellement utilisé</br>
                                    glUseProgram(shader_program);</br></br>
                                    // Paramètre nécessaire</br>
                                    int taille_actuelle = 0;</br>
                                    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3, (void*)taille_actuelle);</br>
                                    glEnableVertexAttribArray(0);
                                </div>
                                Nous définissons "shader_program" comme le shader actuellement utilisé avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgram.xhtml" target="_blank">glUseProgram()</a>.
                                En suite, nous définissons une nouvelle entrée pour le vertex shader, via <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" target="_blank">glVertexAttribPointer()</a>.
                                Le premier paramètre prend la position de l'entrée actuelle passée.
                                Si vous passez plusieurs entrée (ce que nous ferons plus tard), il faut mettre le nombre nécessaire pour chaque entrées.
                                Le deuxième paramètre représente le nombre de données prise par cette variable.
                                En d'autre terme, <u>il s'agit de la taille du vecteur représenté par cette variable (ou 1 si il ne s'agit pas d'un vecteur)</u>.
                                Le troisième paramètre représente le type d'un composant du vecteur, ici un "float".
                                Le quatrième paramètre indique si OpenGL doit normaliser le vecteur ou non.
                                Le cinquième paramètre représente le nombre total d'octets entre deux occurences de cette entrée dans le VBO.
                                Pour finir, le dernier paramètre représente le décalage nécessaire à partir du début de toutes les données dans un shader par rapport à la première donnée pour arriver à celle-ci.
                                En quelque sorte, <u>c'est la position de cette donnée par rapport aux autres</u>.
                                Plus précisement, il s'agit d'un pointeur vers une variable contenant cette donnée (ici taille_actuelle).
                                <span class="important">Petite précision : cette fonction nécessite que le VBO est déjà été crée et qu'il soit défini comme VBO actuel d'OpenGL : nous verrons comment bien s'organiser avec ça après</span>.
                                En suite, cette entrée (ou du moins, l'entrée ayant comme position le paramètre de la fonction) est validée au shader par <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" target="_blank">glEnableVertexAttribArray()</a>.
                                Finalement, comme toujours, nous devons libérer la mémoire à la fin du programme.
                                <div class="code_sample">
                                    // Suppression de la mémoire</br>
                                    glDeleteProgram(shader_program);
                                </div>
                                <span class="important">Maintenant, nous pouvons utiliser ce shader</span>.
                            </p>
                            <p>
                                Finalement, <span class="important">nous allons pouvoir commencer à créer le shader</span>.
                                Cependant, cette étape va devoir reprendre toutes les étapes que nous avons vu dans cette partie.
                                Donc, <u>nous allons créer pleins de fonctions, qui reprennent tout ce que l'on n'a fait sous un seul nom</u>.
                                <ul>
                                    <li>
                                        Le chargement d'un VBO (plaçage des points dans l'espace mémoire) sera assurée par une fonction "charger_vbo".
                                    </li>
                                    <li>
                                        La création et chargement d'un shader sera assurée par une fonction "creer_shader".
                                    </li>
                                    <li>
                                        La création d'un VBO (de ces points et de son espace mémoire) sera assurée par une fonction "creer_vbo".
                                    </li>
                                    <li>
                                        La suppression d'un shader sera assurée par une fonction "supprimer_shader".
                                    </li>
                                    <li>
                                        La suppression d'un VBO sera assurée par une fonction "supprimer_vbo".
                                    </li>
                                </ul>
                                Après tout ça, votre code avant la boucle devrait ressembler à ça.
                                <div class="code_sample">
                                    // Créer le VBO</br>
                                    VBO* vbo = creer_vbo();</br>
                                    charger_vbo(vbo);</br></br>
                                    // Créer le shader</br>
                                    unsigned int shader = creer_shader();
                                </div>
                                Nous allons partir de cette base pour créer le VAO.
                                Commençons par créer le VAO dans la mémoire.
                                <div class="code_sample">
                                    // Créer le VAO</br>
                                    unsigned int vao;</br>
                                    glGenVertexArrays(1, &vao);
                                </div>
                                Ici, c'est <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" target="_blank">glGenVertexArrays()</a> qui s'en occupe, toujours avec le système de "unsigned int".
                                Une fois le VAO crée, attachons-y le VBO, que nous créeons donc à cet instant là.
                                <div class="code_sample">
                                    // Attache du VBO</br>
                                    glBindVertexArray(vao);</br>
                                    VBO* vbo = creer_vbo();</br>
                                    charger_vbo(vbo);
                                </div>
                                <u>L'ordre d'appel est très important ici, et c'est pour ça qu'on a découpé le programme en fonctions plus précises</u>.
                                Nous commençons par fait de "vao" le VAO actuellement utilisé par OpenGL avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" target="_blank">glBindVertexArray()</a>, puis nous créeons le VBO juste après.
                                En suite, viens la création du shader, qui doit avoir lieu après celle du VBO (comme nous avons vu plus haut).
                                <div class="code_sample">
                                    // Créer le VAO</br>
                                    unsigned int vao;</br>
                                    glGenVertexArrays(1, &vao);</br></br>
                                    // Attache du VBO (vous pouvez créer le VBO avant / après "glBindVertexArray()", mais obligatoirement le charger après)</br>
                                    VBO* vbo = creer_vbo();</br>
                                    glBindVertexArray(vao);</br>
                                    charger_vbo(vbo);</br></br>
                                    // Créer le shader</br>
                                    unsigned int shader = creer_shader();
                                </div>
                                Maintenant que tout cela est fait, <span class="important">utilisons notre VAO pour effectuer un rendu fonctionnel</span>.
                                Tout ce qui va suivre doit, en toute logique, se trouver dans la boucle d'exécution.
                                <div class="code_sample">
                                    // Dessin du triangle</br></br>
                                    // Shader actuellement utilisé</br>
                                    glUseProgram(shader);</br></br>
                                    // Tracer les points via le VAO</br>
                                    glBindVertexArray(vao);</br>
                                    glDrawArrays(GL_TRIANGLES, 0, cube.points.size() / 3.0);
                                </div>
                                Nous devons réutiliser la fonction "glUseProgram()", pour dire à OpenGL qu'on utilise ce shader.
                                En suite, nous définissons "vao" comme la VAO utilisé actuellement par OpenGL, grâce à "glBindVertexArray()".
                                Pour finir, <span class="important">le traçage des formes sur le contexte actuel est ordonné par la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" target="_blank">glDrawArrays()</a></span>.
                                Elle prend en premier paramètre le type de forme à tracer, en deuxième paramètre le décalage nécessaire de données dans le VBO pour commencer le traçage (avec ici aucun décalage), et finalement en troisième paramètre le nombre de points à tracer.
                                Théoriquement, <span class="important">votre triangle devrait être bien tracé sur votre fenêtre OpenGL</span>.
                            </p>
                            <img alt="Fenêtre OpenGL avec un triangle" src="../../images/cpp_opengl/triangle.png" style="max-height:300px;">
                        </div>
                        <h3>d. Communiquer avec les objets OpenGL</h3>
                        <div>
                            <p>
                                Imaginez que vous vouliez bouger votre objet.
                                Comment faire ?
                                <u>On peut penser qu'il faut agir sur le VBO, mais modifier le VBO à chaque boucle prendrait beaucoup de temps</u>.
                                <span class="important">À la place, nous allons utiliser un système permettant de communiquer de manière rapide et simple avec les shaders : les variables "uniform"</span>.
                                En effet, les variables notées "in" dans le shader ne peuvent pas être modifiée sans modifier le VBO.
                                <span class="important">Les variables "uniform" peuvent être modifiée quand vous le souhaitez depuis le programme principal</span>.
                                Pour bouger le shader, c'est ici que les mathématiques et GLM entrent en jeu.
                                En effet, notre vertex shader prend des points 3D, nous devons donc utiliser un moyen mathématique de bouger ces points 3D facilement.
                                Ici, <u>on va utiliser le système de calcul matriciel</u>.
                                Nous ne rentrerons pas dans les détails (GLM le fera pour nous), cependant les transformations que nous allons faire sont parfaitement applicables avec des matrices.
                                Nous allons appliquer des <a href="https://fr.wikipedia.org/wiki/Translation" target="_blank">translations</a>, des <a href="https://fr.wikipedia.org/wiki/Homoth%C3%A9tie" target="_blank">homothéties (remise à l'échelle, aggrandissement / rétrecissement)</a> et des <a href="https://fr.wikipedia.org/wiki/Rotation_affine" target="_blank">rotations</a>.
                                Pour cela, nous aurons besoin de matrices de dimension 4X4.
                                Ajoutons la au shader.
                                <div class="code_sample">
                                    // Vertex</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Données du VBO (vec3 représente un point 3D)</br>
                                    layout(location = 0) in vec3 pos; // Position du point P</br></br>
                                    // Données du programme principal</br>
                                    uniform mat4 transformation;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Calcul du point retourné par le shader</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;gl_Position = transformation * vec4(pos.xyz, 1.0);</br>
                                    }
                                </div>
                                En GLSL, une matrice utilise le type "mat4".
                                Pour appliquer les transformations dans le shader, nous avons juste à multiplier la matrice aux coordonnées du points.
                                Finalement, ajoutons du code au programme principal, pour appliquer des transformations.
                                Nous devons commencer par inclure les librairies GLm que nous utiliserons ici.
                                <div class="code_sample">
                                    #include &lt;glm/glm.hpp&gt;</br>
                                    #include &lt;glm/gtc/matrix_transform.hpp&gt;</br>
                                    #include &lt;glm/gtc/type_ptr.hpp&gt;
                                </div>
                                Nous pouvons maintenant commencer les choses sérieuses.
                                <div class="code_sample">
                                    // Calcul de la transformation</br>
                                    glm::mat4 transformation = glm::mat4(1);</br>
                                    // Translation de la matrice</br>
                                    transformation = glm::translate(transformation, glm::vec3(-0.5, 0, 0.2));</br>
                                    // Rotation de la matrice</br>
                                    transformation = glm::rotate(transformation, 0.5f, glm::vec3(0, 0, 1));</br>
                                    // Remise à l'échelle de la matrice</br>
                                    transformation = glm::scale(transformation, glm::vec3(0.8, 1.0, 0.4));</br></br>
                                    // Shader actuellement utilisé</br>
                                    glUseProgram(shader);</br>
                                    // Passage de la variable uniforme</br>
                                    int variable_uniform = glGetUniformLocation(shader, "transformation");</br>
                                    glUniformMatrix4fv(variable_uniform, 1, GL_FALSE, glm::value_ptr(transformation));</br></br>
                                    // Tracer les points via le VAO</br>
                                    glBindVertexArray(vao);</br>
                                    glDrawArrays(GL_TRIANGLES, 0, cube.points.size() / 3.0);
                                </div>
                                Commençons par créer la transformation, avec une matrice 4X4, de type "glm::mat4".
                                Pour être précis, nous créeons ici une matrice diagonale (avec des 1).
                                En suite, <u>nous obtenons une matrice transformé par translation de "transformation", qui sera la nouvelle valeur de "transformation"</u>.
                                Pour cela, on utilise la fonction "translate()" de GLM, qui prend une matrice à transformer, ainsi que la translation à appliquer, et renvoie le résultat.
                                Nous faisons la même avec la rotation, grâce à la fonction "rotate()" de GLM.
                                Elle est un peu plus complexe : elle prend une matrice à transformer, ainsi qu'un angle en radians (OBLIGATOIREMENT UN "FLOAT", pas de "double" autorisé), et finalement l'axe sur lequel appliquer la rotation (ici l'axe Z).
                                En effet, en 3D, les rotations se font autour d'un axe.
                                Finalement, on utilise la fonction "scale()" de GLM, qui prend une matrice à transformer, ainsi que la remise à l'échelle à appliquer, et renvoie le résultat.
                                Dés que cela est fait, <span class="important">nous passons cette matrice au shader</span>.
                                Cette étape doit impérativement avoir lieu après "glUseProgram(shader)".
                                Pour cela, nous commençons par obtenir un "int" pour accéder à la variable uniform "transformation" du shader "shader", grâce à <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml" target="_blank">glGetUniformLocation()</a>.
                                Finalement, nous passons la variable au shader, avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform.xhtml" target="_blank">glUniformMatrix4fv</a>.
                                Son premier paramètre représente "l'int" d'accés à la variable.
                                Le deuxième renvoie le nombre de données qui vont être passées, et la troisième si la matrice doit être transposer (une opération matricielle, ici inutile) ou non.
                                Le dernier paramètre fourni à OpenGL un pointeur vers les données de la matrices, se trouvant à l'adresse renvoyée par "glm::value_ptr(transformation)".
                                <span class="important">Si tout est bien fait, votre triangle devrait subir ses première transformations</span>.
                                En modifiant les valeurs comme vous voulez, vous pouvez faire faire ce que vous voulez à votre triangle.
                                D'ailleurs, <span class="important">vous pouvez utiliser des variables "uniform" dans le vertex shader, mais aussi dans le fragment shader</span>.
                            </p>
                            <img alt="Fenêtre OpenGL avec un triangle transformé" src="../../images/cpp_opengl/triangle_transformation.png" style="max-height:300px;">
                            <p>
                                Pour utiliser pleinement ce système, il y a quelques petits détails à rajouter.
                                Premièrement, <span class="important">vous pouvez dessiner avec un même VAO et un même shader autant que vous voulez en une fois, en modifiant seulement les variables "uniform" si vous le souhaitez</span>.
                                Par exemple, <u>vous pouvez très bien créer un "std::vector" (une liste dynamique) de différentes transformations, et toutes les dessiner à chaque fois</u>.
                                Comme ça, vous pouvez faire des choses plus complètes.
                                De plus, <span class="important">il est tout à fait possible de faire bouger (ou tourner, ou grossir / rétrécir) dans le temps des objets</span>.
                                Dans ce cas, à chaque frame, l'objet occupera une position différente.
                                Bien que vous ayez beaucoup de façon de faire, je vais vous en montrer une assez générale.
                                Première, vous aurez besoin d'un indicateur de temps, ici une fonction que nous appellerons "time_ns()", et qui renvoie le nombre de nano-secondes depuis 1970.
                                <div class="code_sample">
                                    // Retourne le nombre de nano-secondes depuis 1970</br>
                                    long long time_ns() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;timespec ts;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;clock_gettime(CLOCK_REALTIME, &ts);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;return static_cast&lt;long long&gt;(ts.tv_nsec) + static_cast&lt;long long&gt;(ts.tv_sec) * 1000000000;</br>
                                    };
                                </div>
                                À chaque début de frame, stocker le temps actuel dans une variable (de type "long long"), et comparez le avec l'ancienne valeur stockée (sauf si aucune valeur n'est déjà stockée).
                                Vous aurez la durée en nano-secondes de la dernière frame (divisez là par 1 milliard pour obtenir le temps en secondes).
                                <div class="code_sample">
                                    // Obtenir la durée en seconde de la dernière frame</br>
                                    long long temps_actuel = time_ns();</br>
                                    long long duree_frame_en_seconde = static_cast&lt;double&gt;(temps_actuel - dernier_temp) / 1000000000.0;</br>
                                    dernier_temp = temps_actuel;
                                </div>
                                Comme ça, vous saurez de quel distance l'objet à bouger PENDANT la dernière frame, ce qui vous permettra de bouger correctement l'objet.
                                En suite, vous pouvez définir une variable de type "glm::vec3" / "double" / tout ce que vous voulez, qui correspond à la position (ou rotation...) de l'objet, que vous changez à chaque frame.
                                Pour rendre vos animations plus complètes, il y a une dernière chose que vous pouvez faire.
                                <span class="important">Pour savoir quand et comment un utilisateur a intéragi avec le système d'exploitation, il existe plusieurs fonctions différentes : <a href="https://www.glfw.org/docs/3.3/group__input.html#gadd341da06bc8d418b4dc3a3518af9ad2" target="_blank">glfwGetKey()</a> pour les touches du clavier, ou même <a href="https://www.glfw.org/docs/3.3/input_guide.html#input_mouse_button" target="_blank">glfwGetMouseButton()</a> pour les touches de la souris</span>.
                                Comme ça, vous pouvez faire à ce que la réaction de l'objet dépende des entrées de l'utilisateur.
                                <div class="code_sample">
                                    // Obtenir l'état de la touche "A" du clavier</br>
                                    int touche_a = glfwGetKey(window, GLFW_KEY_A);</br>
                                    if (touche_a == GLFW_PRESS) {std::cout &lt;&lt; "La touche A est pressée." &lt;&lt; std::endl; }</br></br>
                                    // Obtenir l'état de la touche gauche de la souris</br>
                                    int etat_souris_gauche = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT);</br>
                                    if (etat_souris_gauche == GLFW_PRESS) {std::cout &lt;&lt; "La touche gauche de la souris est pressée." &lt;&lt; std::endl; }
                                </div>
                                Petit bonus : voici le VBO nécessaire pour réaliser un carré.
                                <div class="code_sample">
                                    // Création du VBO nécessaire</br>
                                    VBO cube;</br></br>
                                    // Création d'un carré</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0);
                                </div>
                            </p>
                        </div>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        B. Utilisez des concepts récents
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <h3>a. Ajouter des textures</h3>
                        <div>
                            <p>
                                Pour l'instant, nos objets ne peuvent avoir qu'une seule couleur (ou, du moins, autant que le shader en permet).
                                Maintenant, <span class="important">ajoutons des textures pour nos objets</span>.
                                La première étape est probablement la plus complexe : <u>charger la texture</u>.
                                Pour charger la texture, plusieurs formats sont disponibles, même si nous allons utiliser le plus simple (pour l'instant) : le RGBA 8 bits.
                                En effet, quand vous chargerez votre texture, <span class="important">vous aurez besoin de charger la texture dans un bloc de données, de telle manière que chaque pixel soit composé de 4 composants (rouge, vert, bleu et alpha), que chacun de ces composants occupent 8 bits (ou 1 octet / 1 "char"), placés 1 par 1 l'un après l'autre</span>.
                                En toute logique, <u>il y aura autant de composants dans l'image que de données dans le bloc de données, donc 4 * largeur * hauteur</u>.
                                Cependant, une grande partie des formats d'images modernes ne sont pas des pixels brutes.
                                En effet, <u>il s'agit souvent d'un bloc de données représentant des pixels bruts mélangés et comprimés pour gagner de la mémoire</u>.
                                Dans le cas du PNG, il s'agit de plusieurs blocs, compressés avec le système de compression <a href="https://fr.wikipedia.org/wiki/Deflate" target="_blank">deflate</a>.
                                À partir de là, deux choix s'offrent à vous : créer votre propre système de chargement d'image ou utiliser un système déjà existant.
                                Pour la suite de ce cours, <span class="important">nous allons utiliser notre propre librairie d'image : <a href="https://aster-system.github.io/scls/scls_image.html" target="_blank">SCLS Image "Michelangelo"</a></span>.
                                N'oubliez pas de l'inclure et d'appeler SCLS_INIT.
                                Grâce à elle, le chargement sera assez simple :
                                <div class="code_sample">
                                    // Charger l'image</br>
                                    scls::Image texture_1 = scls::Image("textures/labyrinthe.png");
                                </div>
                                Pour l'instant, la librairie ne supporte ques des formats PNG.
                                Comme pour les VBOs, nous allons mettre tout ça dans une structure, pour l'utiliser plus facilement.
                                <div class="code_sample">
                                    // Structure pour une texture</br>
                                    struct Texture {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Texture(std::string path):image(path){};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;scls::Image image;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// ID d'accés à la texture</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;unsigned int id;</br>
                                    };</br></br>
                                    Texture texture_1 = Texture("textures/labyrinthe.png");
                                </div>
                                Maintenant, nous pouvons nous concentrer sur OpenGL.
                            </p>
                            <p>
                                Avec OpenGL, <span class="important">le système de texture est directement implémenté dans la librairie</span>.
                                Donc, ce ne sera pas si compliqué que ça à faire.
                                Pour commencer, <u>nous allons spécifier à OpenGL comment la texture doit s'afficher sur l'objet, via le VBO</u>.
                                En fait, on va indiquer à OpenGL la position sur l'image de chaque point de l'objet, pour lui assigner un pixel de l'image.
                                Pour cela, <u>nous allons rajouter une variable d'entrée au shader, qui représentera la position de l'image pour ce point, soit un vecteur 2D, après la position 3D du point</u>.
                                Dans le cas de notre carré (car il est plus facile de réaliser cette opération sur un carré), chaque point représente un coin de l'image (en haut à droite / à gauche ou en bas à droite / à gauche).
                                Voici le nouveau VBO nécessaire :
                                <div class="code_sample">
                                    // Création du VBO nécessaire</br>
                                    VBO cube;</br></br>
                                    // Création d'un carré</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(1.0);</br>
                                    // Point 2</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(0.0);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(0.0);</br>
                                    // Point 4</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(1.0);</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(1.0);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(0.0);
                                </div>
                                Pour que OpenGL le comprenne, il faut aussi le spécifier à la création du shader.
                                Pour cela, on va remplacer les lignes de codes pour le paramètres par de nouvelles :
                                <div class="code_sample">
                                    // Paramètre nécessaire pour la position</br>
                                    int taille_actuelle = 0;</br>
                                    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)taille_actuelle);</br>
                                    glEnableVertexAttribArray(0);</br>
                                    // Paramètre nécessaire pour la position de la texture</br>
                                    taille_actuelle = 3 * sizeof(float);</br>
                                    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)taille_actuelle);</br>
                                    glEnableVertexAttribArray(1);
                                </div>
                                Pour en finir avec le passage de la variable, nous allons devoir la rajouter au vertex shader.
                                La modification est assez simple : on n'a juste qu'à rajouter la variable en variable "in" et en variable "out" pour le fragment shader.
                                <div class="code_sample">
                                    // Vertex</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Données du VBO (vec3 représente un point 3D)</br>
                                    layout(location = 0) in vec3 pos; // Position du point P</br>
                                    layout(location = 1) in vec2 pos_texture; // Position sur la texture du point P</br></br>
                                    out vec2 position_texture; // Position sur la texture du point P</br></br>
                                    // Données du programme principal</br>
                                    uniform mat4 transformation;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Passage des variables "out"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;position_texture = pos_texture;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Calcul du point retourné par le shader</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;gl_Position = transformation * vec4(pos.xyz, 1.0);</br>
                                    }
                                </div>
                                Une petite chose à noter : OpenGL s'occupera d'attribuer à chaque pixel précis le "position_texture" nécessaire lors de la rasterization.
                                Donc, pouvons maintenant afficher l'image comme bon nous semble.
                            </p>
                            <p>
                                Finalement, <span class="important">passons à la manipulation de la texture en elle même</span>.
                                Pour commencer, <u>occupons nous du fragment shader</u>.
                                Nous avons deux choses à rajouter : la variable d'entrée "position_texture" et un moyen d'accéder à la texture, que nous ferons via une variable "uniform".
                                <div class="code_sample">
                                    // Fragment</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Position du pixel dans la texture</br>
                                    in vec2 position_texture;</br></br>
                                    // Couleur sortie du shader</br>
                                    out vec4 FragColor;</br></br>
                                    // Texture nécessaire</br>
                                    uniform sampler2D texture_0;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp&nbsp;// Calcul de la couleur nécessaire, avec ici le rouge, ou RGBA(255, 0, 0, 255)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;FragColor = texture(texture_0, position_texture);</br>
                                    }
                                </div>
                                Ici, <u>la texture est de l'objet "sampler2D", représentant un tableau d'objets 2D (ici, un tableau de pixels)</u>.
                                Le nom "texture_0" est nécessaire ici (il y a plusieurs nom réservés de texture, dont "texture_0").
                                Pour avoir la bonne valeur du pixel de l'image selon "position_texture", nous utilisons la fonction OpenGL <a href="https://www.khronos.org/opengl/wiki/Sampler_(GLSL)#Basic_texture_access" target="_blank">texture()</a>.
                                Elle nous facilitera le travail.
                                Maintenant, les modifications devront être apportées au code principal.
                                Pour en finir, <span class="important">passons et utilisons cette texture dans le code principal</span>.
                                Commençons par créer la texture.
                                <div class="code_sample">
                                    // Charger la texture</br>
                                    Texture texture_1 = Texture("textures/labyrinthe.png");</br>
                                    glGenTextures(1, &texture_1.id);
                                </div>
                                Pour cela, on utilise (encore) le système avec un "unsigned int", et la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTextures.xhtml" target="_blank">glGenTextures()</a> d'OpenGL, qui fonctionne exactement comme les fonctions de génération d'OpenGL.
                                En suite, chargeons la texture dans la mémoire d'OpenGL.
                                <div class="code_sample">
                                    // Passer la texture</br>
                                    glBindTexture(GL_TEXTURE_2D, texture_1.id);</br>
                                    GLint color_format = GL_RGBA; if(texture_1.image.color_type() != 6){color_format = GL_RGB;}</br>
                                    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_1.image.width(), texture_1.image.height(), 0, color_format, GL_UNSIGNED_BYTE, texture_1.image.datas()->datas());</br>
                                    glGenerateMipmap(GL_TEXTURE_2D);
                                </div>
                                Premièrement, nous indiquons à OpenGL que la texture 2D actuellement utilisée est "texture_1.id" avec la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTexture.xhtml" target="_blank">glBindTexture()</a>.
                                Elle fonctionne de la même façon que "glBindBuffer()" ou "glBindVertexArray()".
                                De plus, <span class="important">le shader va utiliser l'image actuellement "bind" lors de l'affichage</span>, il faut donc y penser si vous utilisez plusieurs textures.
                                En suite, nous cherchons si notre image est sous le forma "RGB" ou "RGBA" avec les outils de notre libraririe d'image.
                                Nous stockong le résultat dans la variable "color_format", de type <a href="https://www.khronos.org/opengl/wiki/OpenGL_Type" target="_blank">GLint</a> (un "int" dans OpenGL).
                                Si le type de couleur n'est pas 6, alors l'image est sous le format "RGB", et si le type est de 6, alors elle est sous le format "RGBA".
                                Après, <span class="important">nous passons la texture à OpenGL avec la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml" target="_blank">glTexImage2D()</a></span>.
                                Son premier paramètre représente l'endroit où l'image sera stockée (donc, ici, l'image 2D actuellement utilisée, soit "texture_1.id").
                                Le deuxième paramètre représente le niveau de détail de l'image (contre toute attente, plus il est haut, moins l'image est détaillée).
                                Le troisème paramètre représente interne de l'image représente le type de l'image stocké dans dans la mémoire OpenGL (RGB, RGBA...).
                                Le quatrième paramètre représente la largeur  de l'image, le cinquième sa hauteur, le sixième une valeur toujours à 0 (allez savoir pourquoi) et le septième représente le type de l'image que l'on va passer à OpenGL (RGB ou RGBA, selon "color_format").
                                Finalement, <u>le dernier paramètre représente un pointeur vers un "char*" contenant l'image</u>.
                                Dés que cela est fait, nous appelons la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml" target="_blank">glGenerateMipmap()</a>.
                                Cette fonction va générer des mipmaps pour une certaine texture, ici la texture 2D actuellement utilisée.
                                En fait, <span class="important">les mipmaps représentent des versions moins détaillées de l'image (et donc moins demandantes en ressources), qu'on peut utiliser à la place de l'image de base dans un contexte où l'objet l'utilisant est éloigné de la caméra (et donc, que la texture apparaît plus petite que prévue)</span>.
                                Nous l'ajoutons pour des raisons de performances.
                                Théoriquement, si tout est bien fait, <span class="important">tout devrait marcher comme prévu</span>.
                            </p>
                            <p>
                                Cependant, <span class="important">paramétrons un peu le système de texture</span>.
                                Pour commencer, <span class="important">définissons le comportement de l'image lorsque l'on agrandit ou qu'on rétrécit l'image</span>.
                                Pour cela, nous aurons besoin d'une seule fonction : <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" target="_blank">glTexParameter()</a>.
                                <div class="code_sample">
                                    // Paramétrer la texture</br>
                                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST); // Agrandissement de la texture</br>
                                    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST_MIPMAP_NEAREST); // Rétrécissement of the texture
                                </div>
                                En réalité, <u>il existe plusieurs formes de cette fonction, toutes différenciées par une (ou des) lettre à la fin, représentant le type du paramètre pris (int, float...)</u>.
                                Le premier paramètre représente l'image à paramétrer (ici, l'image 2D actuellement "bind").
                                <u>Le deuxième paramètre représente le paramètre à modifier</u>.
                                Dans le premier cas, il s'agit du comportement de l'image lors d'un agrandissement.
                                Dans le deuxième cas, il s'agit du comportement de l'image lors d'un rétrécissement.
                                Le troisième paramètre représente le paramètre actuel de cette texture.
                                Dans les deux cas, nous utilisons la méthode "GL_NEAREST_MIPMAP_NEAREST" : retournant le pixel le plus proche de la position précise de chaque point du VBO, sur le mipmap le plus proche correspondant au zoom actuel.
                                D'autres valeurs existent, comme "GL_LINEAR", qui retourne un mélange des pixels les plus proches de la position précise de chaque point du VBO.
                                Beaucoup de paramètres sont disponibles, documentés <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameter.xhtml" target="_blank">sur cette page</a>.
                                D'ailleurs, <span class="important">il est important de rajouter que la présence d'un canal alpha peut mettre OpenGL en difficulté</span>.
                                Pour y remédier, <u>on va devoir activer les canaux alphas et dire à OpenGL comment les traiter</u>.
                                L'activation est assez simple.
                                <div class="code_sample">
                                    // Activer le canal alpha</br>
                                    glEnable(GL_BLEND);</br>
                                    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
                                </div>
                                On utilise la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnable.xhtml" target="_blank">"glEnable()"</a>, qui permet d'activer un concept OpenGL, et on active "GL_BLEND", permettant de traiter les canaux alphas.
                                En suite, on dit à OpenGL comment traiter l'opération permettant d'utiliser les canaux alphas (nommée le "blending"), avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" target="_blank">"glBlendFunc()"</a>.
                                Le premier paramètre représente les canaux sources de l'opération, ici le canal "alpha" via "GL_SRC_ALPHA".
                                Le deuxième paramètre représente la façon de traiter ce canal, ici en appliquant l'algorithme basique de transparence "GL_ONE_MINUS_SRC_ALPHA".
                                On doit rajouter cela après l'initialisation de Glad.
                            </p>
                            <p>
                                Avant d'en finir, <u>il reste un dernier truc à représenter avec ce système de texture</u>.
                                Bien que, pour l'instant, nous n'utilisons que des textures externes, <span class="important">nous pouvons aussi utiliser les shaders (et leur puissance) pour générer des textures bien précises dans ces derniers</span>.
                                Cependant, pour faire cela, <u>il nous faut de bon modèle mathématiques, capables de générer de tels images</u>.
                                Le meilleur exemple est l'ensemble de Mandelbrot, et le fractale qu'il forme.
                                Il s'agit d'un ensemble de suites mathématiques de nombres complexes à deux paramètres (un complexe et un entier pour la suite), caractérisées par leur limite en + l'infini.
                                En cherchant si une suite d'un certain nombre complexe tend vers + l'infini en + l'infini, et en lui attribuant une couleur sur le plan complexe selon le résultat, nous pouvons créer une forme... totalement imprévue.
                                Pour plus d'informations, <a href="https://fr.wikipedia.org/wiki/Ensemble_de_Mandelbrot" target="_blank">rendez-vous ici</a>.
                                Si vous voulez voir quelqu'un en développer un de manière plus précise, <a href="https://youtu.be/wUlVFYJIUNA?si=oJqXkEl7onabDSxO" target="_blank">je vous conseille cette vidéo de dimension code</a>.
                                Voici un petit exemple de shader modifié pour accueillir un fractale de Mandelbrot.
                                <div class="code_sample">
                                    // Fragment "Mandelbrot"</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Position du pixel dans la texture</br>
                                    in vec2 position_texture;</br></br>
                                    // Couleur sortie du shader</br>
                                    out vec4 FragColor;</br></br>
                                    // Texture nécessaire</br>
                                    uniform sampler2D texture_0;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// On cherche la valeur complexe du pixel actuel (dans un plan complexe entre x = -5 et x = 5, et y y -5 et y = 5)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;float x = (position_texture.x - 0.5) * 5.0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;float y = (position_texture.y - 0.5) * 5.0;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// On définit le nombre d'itération de la suite actuel, ainsi que la limite à partir de laquelle la suite sera considérée comme "tendant vers + l'infini"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;float current_x=0;float current_y=0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;float iter=0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;float limit=100.0;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Boucle d'exécution pour la suite</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;for(;iter&lt;100;iter++){</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// On calcul les valeurs actuelles complexes de la suite</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float temp=current_x;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_x=current_x*current_x-current_y*current_y;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_y*=2.0*temp;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_x+=x;current_y+=y;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Si la suite est trop grande, on sort de la boucle</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(sqrt(current_x*current_x+current_y*current_y)>limit){break;}</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;}</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Si la suite ne tend pas, on affiche du noir</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;if(iter==100){FragColor = vec4(0, 0, 0, 1.0);}</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Sinon, on affiche une couleur représentant la vitesse à laquelle la suite tend</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;else{FragColor = vec4(iter / 100.0, iter / 100.0, 1.0, 1.0);}</br>
                                    }
                                </div>
                                Pensez bien à ce genre de propriétés pour les shaders, elles pourraient nous être très utiles dans les temps à venir.
                            </p>
                            <img alt="Fractale de Mandelbrot" src="../../images/cpp_opengl/mandelbrot.png" style="max-height:300px;">
                        </div>
                        <h3>b. Utiliser de la 3D</h3>
                        <div>
                            <p>
                                Aussi effrayant qu'elle puisse être, <u>l'ajout de la 3D ne sera pas si complexe que ça</u>.
                                Pour commencer, <span class="important">nousa allons définir un objet très utilisé dans les jeux vidéos : une caméra</span>.
                                Pour notre caméra, nous aurons besoin de quelques données assez évidentes.
                                <div class="code_sample">
                                    // Structure pour une caméra</br>
                                    struct Camera {</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Position de la caméra</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double x = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double y = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double z = 0;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Vecteur directeur de la vue de la caméra</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double angle = 1.570796;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double vue_x = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double vue_y = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double vue_z = 1;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// FOV de la caméra (en degrés d'angle)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double fov = 45;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Distance de rendu de la caméra</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double rendu_loin = 1000;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double rendu_proche = 0.001;</br>
                                    };
                                </div>
                                Heuresement, <u>le combo GLM et calcul matriciel va nous permettre de rendre tout ça très facile</u>.
                                <span class="important">Commençons par implémenter les choses nécessaires dans le shader</span>.
                                En réalité, nous n'allons que rajouter 2 variables "uniform" dans le vertex shader : 2 matrices pour utiliser de la 3D.
                                <div class="code_sample">
                                    // Vertex</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Données du VBO (vec3 représente un point 3D)</br>
                                    layout(location = 0) in vec3 pos; // Position du point P</br>
                                    layout(location = 1) in vec2 pos_texture; // Position sur la texture du point P</br></br>
                                    out vec2 position_texture; // Position sur la texture du point P</br></br>
                                    // Données du programme principal</br>
                                    uniform mat4 transformation;</br></br>
                                    // Données permettant d'afficher de la 3D</br>
                                    uniform mat4 projection;</br>
                                    uniform mat4 view;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Passage des variables "out"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;position_texture = pos_texture;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Calcul du point retourné par le shader</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;gl_Position = vec4(pos.xyz, 1.0);</br>
                                    }
                                </div>
                                Ici, "view" représente la matrice nécessaire pour utiliser la caméra et "projection" représente la matrice permettant d'utiliser un rendu 3D réaliste.
                                Maintenant, <span class="important">importons ces valeurs depuis le programme principal</span>.
                                <div class="code_sample">
                                    // On définit la taille de la fenêtre au début du programme (dans des variables)</br>
                                    int hauteur_fenetre = 1000;</br>
                                    int largeur_fenetre = 1000;</br></br>
                                    ...</br></br>
                                    // Gestion de la caméra</br>
                                    glm::mat4 projection = glm::perspective(glm::radians(cam.fov), static_cast&lt;double&gt;(largeur_fenetre) / static_cast&lt;double&gt;(hauteur_fenetre), cam.rendu_proche, cam.rendu_loin);</br>
                                    glm::mat4 view = glm::lookAt(glm::vec3(cam.x, cam.y, cam.z), glm::vec3(cam.x + cam.vue_x, cam.y + cam.vue_y, cam.z + cam.vue_z), glm::vec3(0, 1, 0));</br></br>
                                    ...</br></br>
                                    // Passage des variables uniformes nécessaires</br>
                                    glUseProgram(shader);</br>
                                    int variable_uniform = glGetUniformLocation(shader, "projection");</br>
                                    glUniformMatrix4fv(variable_uniform, 1, GL_FALSE, glm::value_ptr(projection));</br>
                                    variable_uniform = glGetUniformLocation(shader, "transformation");</br>
                                    glUniformMatrix4fv(variable_uniform, 1, GL_FALSE, glm::value_ptr(transformation));</br>
                                    variable_uniform = glGetUniformLocation(shader, "view");</br>
                                    glUniformMatrix4fv(variable_uniform, 1, GL_FALSE, glm::value_ptr(view));
                                </div>
                                Comme vous l'avez remarquer, nous allons devoir profondément changer notre code.
                                Au début du programme, définissons des valeurs spécifiques pour la taille de la fenêtre, qui nous seront utiles plus tard.
                                En suite, dans la boucle d'exécution, nous créeons les matrices nécessaires à la projection et à la vue caméra.
                                Pour cela, <u>nous utiliserons deux fonctions de GLM</u>.
                                La première est "perspective()", permettant d'avoir la matrice de projection.
                                Cette fonction prend pas mal de paramètres pour les calculs.
                                Le premier paramètre représente le FOV en gradians de la caméra.
                                Le deuxième paramètre représente le ratio largeur/hauteur de l'écran (c'est pour cela que nous avons créer des variables avant).
                                Le troisième et le quatrième représentetn les valeurs "proche" et "loin" de la caméra.
                                Après cela, <span class="important">occupons nous de la vue caméra, avec la fonction "lookAt()"</span>.
                                Son première paramètre représente la position de la caméra.
                                Le deuxième représente le point regardé de la caméra, ici juste devant elle.
                                Le troisième paramètre représente un vecteur directeur du sens, que la caméra considère comme le sens "en haut", donc ici un vecteur pointant vers le haut.
                                Finalement, <u>envoyez toutes ces données à OpenGL, via les variables uniformes</u>.
                                Un petit dernier truc possible : placer correctement l'objet observé dans le plan (dans l'idéal, à la coordonnée (0, 0, 1), pour directement le voir).
                                Dés que cela est fait, votre objet apparaître sous la forme d'un plan carré dans un univers 3D.
                                Si vous voulez vous en rendre compte, essayez d'implémenter un moyen de déplacement de la caméra, et regardez ce que cela donne.
                                Voici un petit exemple de code permettant de naviguer dans votre programme, avec les touches "ZQSD" et rotation via les flèches.
                                <div class="code_sample">
                                    // Tourner la caméra</br>
                                    int touche_ra = glfwGetKey(window, GLFW_KEY_RIGHT);</br>
                                    if (touche_ra == GLFW_PRESS) { cam.angle += 3.1415 * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9)); }</br>
                                    int touche_la = glfwGetKey(window, GLFW_KEY_LEFT);</br>
                                    if (touche_la == GLFW_PRESS) { cam.angle -= 3.1415 * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9)); }</br></br>
                                    // Appliquer la rotation</br>
                                    cam.vue_x = std::cos(cam.angle);cam.vue_z = std::sin(cam.angle);</br></br>
                                    // Bouger la caméra</br>
                                    int touche_d = glfwGetKey(window, GLFW_KEY_D);</br>
                                    if (touche_d == GLFW_PRESS) {cam.x -= cam.vue_z * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9)); cam.z += cam.vue_x * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9));}</br>
                                    int touche_q = glfwGetKey(window, GLFW_KEY_A);</br>
                                    if (touche_q == GLFW_PRESS) {cam.x += cam.vue_z * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9));cam.z -= cam.vue_x * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9)); }</br>
                                    int touche_z = glfwGetKey(window, GLFW_KEY_W);</br>
                                    if (touche_z == GLFW_PRESS) {cam.x += cam.vue_x * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9)); cam.z += cam.vue_z * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9));}</br>
                                    int touche_s = glfwGetKey(window, GLFW_KEY_S);</br>
                                    if (touche_s == GLFW_PRESS) {cam.x -= cam.vue_x * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9)); cam.z -= cam.vue_z * static_cast&lt;float&gt;(static_cast&lt;double&gt;(current - last_frame) / std::pow(10, 9));}</br>
                                </div>
                                Pour faire un tel code, de simples connaissances en géométrie (et, plus précisément, en trigonométrie) sont nécessaires.
                            </p>
                            <img alt="Fractale en 3D" src="../../images/cpp_opengl/mandelbrot_3d.png" style="max-height:300px;">
                            <p>
                                Pour l'instant, on utilise un plan 2D en 3D.
                                Cependant, comment utiliser des objets 3D ?
                                <span class="important">Pour utiliser des objets purement 3D, le plus complexe va être de réaliser leur VBO</span>.
                                Bien que vous pouviez penser à des logiciels de modélisations 3D comem Blender, <u>convertir les types d'objets utilisés par Blender en type "VBO" n'est pas vraiment plus simple que de les faire soit même</u> (on aura le même problème que pour les images).
                                Par exemple, réaliser un simple cube demande de dupliquer 6 fois le VBO vu plus haut.
                                En réalité, <u>ce ne sera pas un problème pour OpenGL, mais pour l'humain qui devra rédiger le VBO chiffres par chiffres</u>.
                                Dans ce cas, <span class="important">il est aussi conseillé de découper votre texture en, partie (sur une seule image), que chaque face ira précisément sélectionner, pour économiser les textures</span>.
                                Comme je suis gentil, voici le VBO nécessaire pour un cube.
                                <div class="code_sample">
                                    // Création du VBO nécessaire</br>
                                    VBO cube;</br></br>
                                    // Création de la face Y+</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(0.49);</br>
                                    // Point 2</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(0.0);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.32);cube.points.push_back(0.0);</br>
                                    // Point 4</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.32);cube.points.push_back(0.49);</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(0.49);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.32);cube.points.push_back(0.0);</br></br>

                                    // Création de la face Y-</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(1.0);</br>
                                    // Point 2</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(0.51);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.32);cube.points.push_back(0.51);</br>
                                    // Point 4</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.32);cube.points.push_back(1.0);</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.0);cube.points.push_back(1.0);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.32);cube.points.push_back(0.51);</br></br>

                                    // Création de la face Z+</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.34);cube.points.push_back(0.0);</br>
                                    // Point 2</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.34);cube.points.push_back(0.49);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.65);cube.points.push_back(0.49);</br>
                                    // Point 4</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.65);cube.points.push_back(0.0);</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.34);cube.points.push_back(0.0);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(0.65);cube.points.push_back(0.49);</br></br>

                                    // Création de la face Z-</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.65);cube.points.push_back(1.0);</br>
                                    // Point 2</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.34);cube.points.push_back(1.0);</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.34);cube.points.push_back(0.51);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.65);cube.points.push_back(1.0);</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.34);cube.points.push_back(0.51);</br>
                                    // Point 4</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.65);cube.points.push_back(0.51);</br></br>

                                    // Création de la face X+</br>
                                    // Point 1</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.67);cube.points.push_back(0.0);</br>
                                    // Point 2</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.67);cube.points.push_back(0.49);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(0.49);</br>
                                    // Point 4</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(0.0);</br>
                                    // Point 1</br>
                                    cube.points.push_back(0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.67);cube.points.push_back(0.0);</br>
                                    // Point 3</br>
                                    cube.points.push_back(0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(0.49);</br></br>

                                    // Création de la face X-</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.67);cube.points.push_back(0.51);</br>
                                    // Point 2</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.67);cube.points.push_back(1.0);</br>
                                    // Point 3</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(1.0);</br>
                                    // Point 4</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(0.51);</br>
                                    // Point 1</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(0.5);cube.points.push_back(-0.5);</br>
                                    cube.points.push_back(0.67);cube.points.push_back(0.51);</br>
                                    // Point 3</br>
                                    cube.points.push_back(-0.5);cube.points.push_back(-0.5);cube.points.push_back(0.5);</br>
                                    cube.points.push_back(1.0);cube.points.push_back(1.0);
                                </div>
                                Comme dit auparavant, chaque face à sa propre partie de la texture.
                                Voici un exemple de texture fonctionnant avec ce VBO.
                                <b>Ne jugez pas mes qualités de dessins</b> (s'il vous plaît).
                            </p>
                            <img alt="Smiley" src="../../images/cpp_opengl/smiley.png" style="max-height:300px;">
                            <p>
                                Ce VBO est fait pour être assez simple d'utilisation avec les textures.
                                Le carré en haut à gauche représente la face haute (Y+), et celui en bas à gauche représente la face basse (Y-).
                                Les deux carrés du milieu représentent la face avec z = 0.5 (Z+) et z = -0.5 (Z-).
                                Dans les deux cas de cette texture, la partie droite représente x = 0.5, pour pouvoir facilement orienter la texture.
                                Enfin, les deux carrés de droites représentent la face avec x = 0.5 (X+) et x = -0.5 (X-).
                                Comme pour Z+ et Z-, la partie droite représente z = 0.5, pour pouvoir facilement orienter la texture.
                                Si vous testez l'affichage comme ça, un phénomène étrange se passe : les faces arrières sont dessinées avant les faces avant.
                                En effet, <span class="important">par défaut, OpenGL dessine les faces comme elles viennent, sans tester laquelle est derrière l'autre</span>.
                                En 3D, cela est très embêtant.
                                Pour y remédier, <span class="important">nous allons ajouter deux lignes de codes à notre programme</span>.
                                Premièrement, nous allons indiquer à OpenGL qu'il va devoir prendre en compte la profondeur pendant l'affichage.
                                <div class="code_sample">
                                    // Activer le test de profondeur</br>
                                    glEnable(GL_DEPTH_TEST);
                                </div>
                                Pour cela, on utilise la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnable.xhtml" target="_blank">glEnable()</a> d'OpenGL, qui prend en paramètre un concpet a activer.
                                Il faut absolument mettre cette fonction après l'initialisation de Glad.
                                En suite, on va aller modifier notre ligne utilisant "glClear()".
                                <div class="code_sample">
                                    // Nettoyer l'écran et le buffer du test de profondeur</br>
                                    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
                                </div>
                                Il est possible que la modification soit déjà faites, mais vérifiez quand même au cas ou.
                                Comme ça, on réalise un test par frame, pour avoir une image propre tout le temps.
                                Maintenant que vous avez ça, <span class="important">vous pouvez mieux comprendre les VBOs et leur fonctionnement, et créer tout ce que vous voulez</span>.
                            </p>
                            <img alt="Smiley 3D" src="../../images/cpp_opengl/smiley_3d.png" style="max-height:300px;">
                        </div>
                        <h3>c. Pleinement contrôler votre fenêtre OpenGL</h3>
                        <div>
                            <p>
                                Pour en finir, <span class="important">voyons quelques petits trucs assez ennuyants, mais très pratiques pour faire une fenêtre OpenGL</span>.
                                Commençons par traiter quelque chose d'assez important : <u>certains évènements de l'application</u>.
                                En effet, comme nous l'avons vu beaucoup plus tôt, la fonction "glfwPollEvents()" permet de traiter les évènements dans le logiciel.
                                Là où certains évènements peuvent être utiliser via des fonctions directes, comme "glfwGetKey()", d'autres ne fonctionnent pas comme ça.
                                Pour être précis, <u>OpenGL va utiliser des fonctions dites "callback" pour traiter ces évènements</u>.
                                Ce sont des fonctions qui seront appelées quand ces évènements arriveront.
                                Pour être précis, <u>nous allons passer des pointeurs vers ces fonctions à OpenGL, qui auront pour tâche d'avertir le logiciel que cet évènement a lieu</u>.
                                Ne vous inquiétez pas, <a href="https://www.glfw.org/docs/3.2/input_guide.html" target="_blank">toutes les informations de documentations sont présentes ici (GLFW s'en charge)</a>.
                                Pour en citer quelques une importantes : <a href="https://www.glfw.org/docs/3.2/input_guide.html#cursor_enter" target="_blank">glfwSetCursorEnterCallback()</a>, <a href="https://www.glfw.org/docs/3.2/input_guide.html#path_drop" target="_blank">glfwSetDropCallback()</a> ou même <a href="https://www.glfw.org/docs/3.2/window_guide.html#window_fbsize" target="_blank">glfwSetFramebufferSizeCallback()</a>.
                            </p>
                            <p>
                                Pour en finir, je vais vous présenter une dernière fonction.
                                <span class="important">Quand vous redimensionner la fenêtre, rien ne change en elle</span>.
                                Premièrement, un redimensionnement de fenêtre est connue via une fonction callback, ici <a href="https://www.glfw.org/docs/3.2/window_guide.html#window_fbsize" target="_blank">glfwSetFramebufferSizeCallback()</a>.
                                Deuxièmement, même avec cette fonction, aucun objet ne va changer dans la fenêtre.
                                En effet, <span class="important">pour correctement redimensionner une fenêtre OpenGL, il faut appeler une autre fonction : <a rehf="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewport.xhtml" target="_blank">glViewport()</a></span>.
                                <div class="code_sample">
                                    // Fonction "callback" d'un redimensionnement de la fenêtre</br>
                                    void framebuffer_size_callback(GLFWwindow* window, int width, int height) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;int screen_height = height; // Peut aussi être une variable globale</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;int screen_width = width; // Peut aussi être une variable globale</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glViewport(0, 0, screen_width, screen_height);</br>
                                    }
                                </div>
                                Cette fonction prend 4 paramètres.
                                Les deux premiers représentent une valeur "x" et "y" pour certains appareils utilisant des systèmes de coordonnées normalisés.
                                Sur Windows et Linux, nous pouvons les mettre à 0.
                                Les deux derniers paramètres représentent <span class="important">la largeur et la hauteur de la fenêtre</span>.
                                Maintenant, votre fenêtre OpenGL devrait être bien dimensionnée.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/saasf" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>