<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - OpenGL en C++</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <a href="../../index.html">
                <img alt="Logo de SAASF" src="../../images/aster_system_logo.png" style="max-height:150px;">
            </a>
        </header>
        <div id="main_div">
            <h1>
                Utiliser OpenGL en C++
            </h1>
            <div>
                Pour l'instant, les seules interactions que nous pouvons avoir avec notre programme C++ sont les fichiers et la console.
                Nous allons ici apprendre à augmenter les possibilités d'interactions avec le programme, grâce à une API très connue : <a href="https://www.khronos.org/opengl/" target="_blank">OpenGL</a>.
                Pour rappel, nous avons déjà fait un cours sur OpenGL, <a href="../../creations/opengl.html">juste ici</a>.
                Pour des raisons de temps, nous allons considérer tout ce qui a été vu sur ce cours comme acquis.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Créez votre fenêtre OpenGL
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <h3>
                            a. Mettre en place votre environnement
                        </h3>
                        <div>
                            <p>
                                Disons le, <u>OpenGL est une librairie assez complexe à utiliser</u>.
                                Pour y accéder, chaque systèmes d'exploitations offrent nativement différents outils pour y accéder.
                                Cependant, pour gagner du temps, <span class="important">nous allons utiliser des librairies C++ qui permettent d'utiliser simplement tout ça</span>.
                                Nous allons utiliser 3 librairies : <a href="https://www.glfw.org/" target="_blank">GLFW</a>, <a href="https://glad.dav1d.de/" target="_blank">Glad</a> et <a href="https://github.com/g-truc/glm" target="_blank">GLM</a>.
                            </p>
                            <p>
                                <span class="important">GLFW va être un moyen simple d'utiliser un contexte OpenGL</span>.
                                En effet, <u>elle est pleine de fonctions très utiles pour travailler avec OpenGL</u>.
                                Elle a l'avantage d'être cross-platforme et en libre accès.
                                Pour installer GLFW, <a href="https://www.glfw.org/download.html" target="_blank">rendez vous sur cette page</a>.
                                Vous pouvez télécharger le code source et le compiler vous même, ou utiliser du code pré-compilé.
                                Pour rappel, nous avons déjà traité de l'utilisation de librairies de ce genre, <a href="../../astersystemelearn/cpp_lessons/cpp_bases.html" target="_blank">dans ce cours là</a>.
                                Vous devrez théoriquement avoir accès a un DLL, deux fichiers librairies, et un ensemble de headers.
                            </p>
                            <p>
                                <span class="important">Glad va avoir pour tâche de rendre notre code OpenGL cross-plateforme</span>.
                                En effet, comme nous l'avons vu, chaque plateforme propose sa propre implémentation d'OpenGL.
                                <u>Glad réuni tous les types possibles, et les rend accessibles selon la plateforme actuelle</u> grâce au système de <a href="../../astersystemelearn/cpp_lessons/cpp_templates.html">template</a>.
                                Pour installer Glad, <a href="https://glad.dav1d.de/" target="_blank">rendez vous sur cette page</a>.
                                Elle vous demandera pas mal de configuration pour le fichier environnement généré.
                                <span class="important">Comme langage, sélectionnez "C/C++"". Comme spécification, sélectionnez "OpenGL". Comem API, sélectionnez "Version 3.3" dans "gl" (Comme sur notre cours d'OpenGL). Comme "Profile", choisissez "Core".</span>
                                Cependant, à l'inverse de GLFW, Glad ne propose pas de fichiers pré-compilés.
                                <u>Le site vous proposera un dossier de headers, ainsi qu'un fichier "glad.c", à ajouter aux fichiers compilés de votre code</u>.
                            </p>
                            <p>
                                Finalement, <span class="important">GLM va nous apporter un ensemble d'outils mathématiques, très importants pour OpenGL</span>.
                                En effet, <u>les mathématiques nécessaires seront très avancés ici</u>.
                                Heuresement, GLM en propose une partie.
                                Pour installer GLM, <a href="https://github.com/g-truc/glm" target="_blank">rendez vous sur cette page</a>.
                                Vous y trouverez l'ensemble du projet GLM.
                                <span class="important">Vous aurez besoin de tous les headers présents dans le dossier "glm"</span>.
                                Dans cette librairie, il n'y a que des headers.
                            </p>
                            <p>
                                Dés que tout cela est installé, vous pouvez créer votre projet pour commencer à travailler avec OpenGL.
                            </p>
                        </div>
                        <h3>
                            b. Créer votre première fenêtre
                        </h3>
                        <div>
                            <p>
                                Pour créer notre première fenêtre avec OpenGL, <span class="important">il va falloir commencer à écrire le code permettant de configurer OpenGL</span>.
                                <u>Nous vous conseillons grandement de bien le structurer, pour pouvoir l'utiliser de manière plus simple</u>.
                                Cependant, si vous avez la flemme (déconseillé), vous pouvez tout mettre directement dans la fonction "main" de votre code.
                                Avant tout, <u>initialisons GLFW, avec quelques simples lignes de code</u>.
                                <div class="code_sample">
                                    // Initialisation de GLFW</br>
                                    glfwInit();</br>
                                    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</br>
                                    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</br>
                                    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
                                </div>
                                Ces fonctions sont assez claires : "glfwInit()" initialise GLFW, et <a href="https://www.glfw.org/docs/3.3/group__window.html" target="_blank">"glfwWindowHint()"</a> permet de configurer certaines valeurs de GLFW, grâce à deux paramètres : la configuration à modifier, et sa nouvelle valeur.
                                Dans ce cas, nous configurons la version (majeure et mineure) d'OpenGL, en 3.3 ici, puis nous indiquons à GLFW que nous utiliser la version "core" d'OpenGL (téléchargée plus haut via Glad).
                                En suite, <u>créeons notre contexte OpenGL</u>.
                                <div class="code_sample">
                                    // Création du contexte OpenGL</br>
                                    GLFWwindow* window = glfwCreateWindow(500, 500, "Mon programme OpenGL", NULL, NULL);</br>
                                    if (window == NULL) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwTerminate();</br>
                                    }</br>
                                    glfwMakeContextCurrent(window);
                                </div>
                                Ces fonctions restent aussi assez claires : "glfwCreateWindow()" crée la fenêtre pour OpenGL et la retourne sous forme de pointeur vers un objet <a href="https://www.glfw.org/docs/latest/group__window.html#ga3c96d80d363e67d13a41b5d1821f3242" target="_blank">"GLFWwindow"</a>, la condition vérifie si la création a bien eu lieu, et "glfwMakeContextCurrent()" indique à GLFW (et, indirectement, à l'OS du PC) que le contexte actuel du programme est le contexte passé en paramètre.
                                Nous pouvons constater la fonction <a href="https://www.glfw.org/docs/3.3/group__init.html#gaaae48c0a18607ea4a4ba951d939f0901" target="_blank">"glfwTerminate()"</a> dans la condition, qui a pour tâche de décharger GLFW pour le programme (si il doit s'arrêter).
                                Attardons nous sur <a href="https://www.glfw.org/docs/latest/group__window.html#ga3555a418df92ad53f917597fe2f64aeb" target="_blank">"glfwCreateWindow()"</a>.
                                Elle prend beaucoup de paramètres.
                                <u>Les deux premiers représentent la largeur et la hauteur de la fenêtre</u>.
                                Le troisième représente le titre affiché en haut à gauche de la fenêtre.
                                Le quatrième représente un pointeur vers un objet <a href="https://www.glfw.org/docs/latest/group__monitor.html#ga8d9efd1cde9426692c73fe40437d0ae3" target="_blank">GLFWmonitor</a>.
                                Si ce pointeur est utilisé, alors le programme va être en plein écran sur l'écran demandé.
                                Sinon (comme maintenant), il ne sera pas en plein écran.
                                Le cinquième permet de lier une autre fenêtre déjà crée avec celle-ci pour un partage de ressources entre fenêtre si besoin (nous n'en aurons pas besoin ici).
                                <span class="important">Si la fenêtre ne peut pas être générée, la fonction renvoie un pointeur nul, et la condition d'erreur est activée, affichant un mesage d'erreur et déchargeant GLFW</span>.
                                En suite, <u>chargeons Glad</u>.
                                <div class="code_sample">
                                    // Chargement de Glad</br>
                                    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwTerminate();</br>
                                    }
                                </div>
                                <span class="important">Glad est chargé dans la fonction "gladLoadGLLoader()", qui renvoie "true" si le chargement est bon, ou "false" si il n'est pas bon</span>.
                                Si il ne l'est pas, la condition d'erreur est activée, affichant un mesage d'erreur et déchargeant GLFW.
                                Cette fonction est assez complexe : elle prend la fonction <a href="https://www.glfw.org/docs/latest/group__context.html#ga35f1837e6f666781842483937612f163" target="_blank">"glfwGetProcAddress()"</a> de GLFW en paramètre, retournant un pointeur vers la bonne API OpenGL utilisée par le contexte actuel.
                                N'hésitez pas à aller voir la documentation si cette fonction vous intéresse.
                                Dés que tout cela est fait, <span class="important">la partie configuration est terminée</span>.
                            </p>
                            <p>
                                Maintenant, <span class="important">nous allons implémenter la boucle qui va permettre à notre programme de tenir dans le temps</span>.
                                Tout aura lieu dans une boucle, qui s'arrêtera en même temps que le programme.
                                La boucle aura cette allure :
                                <div class="code_sample">
                                    // Boucle de temps</br>
                                    while(!glfwWindowShouldClose(window)) {</br></br>

                                    }</br>
                                    glfwTerminate();
                                </div>
                                Ici, <a href="https://www.glfw.org/docs/latest/group__context.html#ga35f1837e6f666781842483937612f163" target="_blank">"glfwWindowShouldClose()"</a> vérifiera si la fenêtre doit se fermer.
                                Après avoir fermer la fenêtre, on décharge GLFW avec "glfwTerminate()".
                                <u>Si nous lançons le programme comme ça, rien ne va se passer, et le programme ne pourra même pas se fermer tout seul</u>.
                                Pour utiliser la fenêtre, nous allons modifier l'intérieur de la boucle.
                                <div class="code_sample">
                                    // Boucle de temps</br>
                                    while(!glfwWindowShouldClose(window)) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Préparer l'affichage OpenGL</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glClearColor(0, 0.4, 0.9, 1.0);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT);</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Met à jour OpenGL</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwSwapBuffers(window);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glfwPollEvents();</br>
                                    }</br>
                                    glfwTerminate();
                                </div>
                                Ce code rend la page tout à fait utilisable : décrivons le étape par étape.
                                <span class="important"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClear.xhtml" target="_blank">"glClear()"</a> permet de remettre les zones mémoires générées auparavant d'OpenGL à 0 (ou ne fait rien si aucune zone mémoire n'a été générée)</span>.
                                Comme ça, vous n'encombrez pas la mémoire de choses inutiles.
                                Ici, on passe en paramètre "GL_COLOR_BUFFER_BIT", pour n'effacer que la partie "couleur" d'OpenGL (l'ancienne zone d'affichage).
                                Il s'agit d'une fonction de base d'OpenGL (rendue utilisable par Glad).
                                Cependant, <u>OpenGL va remplir la nouvelle zone de mémoire d'affichage par une nouvelle couleur, spécifiée via la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearColor.xhtml" target="_blank">glClearColor()</a></u>.
                                Elle prend 4 paramètres : les valeurs RGBA de la couleur nécessaire (qui peuvent être des valeurs sur 255, ramenée à entre 0 et 1).
                                Ces valeurs doivent être entre 0 et 1.
                                Ici, il s'agit d'un bleu ciel (le même que la couleur d'arrière plan de la fenêtre nouvellement crée).
                                En suite, <span class="important">on demande à GLFW de confirmer l'affichage de la fenêtre, qui va être envoyée à la carte graphique avec <a href="https://www.glfw.org/docs/latest/group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14" target="_blank">glfwSwapBuffers()</a></span>.
                                Finalement, <u><a href="https://www.glfw.org/docs/latest/group__window.html#ga37bd57223967b4211d60ca1a0bf3c832" target="_blank">"glfwPollEvents()"</a> met à jour les évènements ayant eu lieu depuis le dernier appel de la fonction (clique de souris, entré clavier, fermeture de la fenêtre...)</u>.
                                Cet données seront par la suite accessible via des fonctions, que nous verrons plus tard.
                                <u>Maintenant que cette fenêtre est crée, commençons à la rendre utilisable</u>.
                            </p>
                            <img alt="Fenêtre OpenGL" src="../../images/cpp_opengl/window.png" style="max-height:300px;">
                        </div>
                        <h3>
                            c. Créer des objets OpenGL
                        </h3>
                        <div>
                            <p>
                                Pour pouvour utiliser pleinement OpenGL, <span class="important">nous allons créer des objets dans OpenGL</span>.
                                Comme nous l'avons vu dans la présentation d'OpenGL, <span class="important">les objets OpenGL sont utilisés via des VAOs, des VBOs et des shaders</span>.
                            </p>
                            <p>
                                <span class="important">Commençons par le plus simple : les VBOs</span>.
                                Pour des raisons de simplicité, nous mettrons l'entiereté des données d'un VBO dans une structure.
                                <div class="code_sample">
                                    // Structure pour un VBO</br>
                                    struct VBO {</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Id du VBO</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;unsigned int id;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Points dans le VBO</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;float&gt; points;</br>
                                    };
                                </div>
                                Nous l'étudierons plus précisément plus tard.
                                Pour passer des VBOs à OpenGL, <u>il vous faut une liste de points</u>.
                                Ici, notre liste sera dans le vecteur "points".
                                <span class="important">Pour commencer simplement, faisons un simple triangle</span> (pour rappel, OpenGL ne peut qu'afficher des triangles).
                                <div class="code_sample">
                                    // Création du VBO nécessaire</br>
                                    VBO triangle;</br></br>
                                    // Création d'un triangle</br>
                                    vbo->points.push_back(-0.5);vbo->points.push_back(-0.5);vbo->points.push_back(0);</br>
                                    vbo->points.push_back(0.5);vbo->points.push_back(-0.5);vbo->points.push_back(0);</br>
                                    vbo->points.push_back(0);vbo->points.push_back(0.5);vbo->points.push_back(0);
                                </div>
                                Dans une fenêtre OpenGL, les extrémités (gauche / droite, bas / haut) représentent les coordonnées -1 et 1.
                                Dés que cela est fait, <u>nous allons les passer à OpenGL</u>.
                                <div class="code_sample">
                                    // Attribution d'un espace mémoire pour le VBO</br>
                                    glGenBuffers(1, &triangle.id);</br></br>
                                    // Passage du VBO à OpenGL</br>
                                    glBindBuffer(GL_ARRAY_BUFFER, triangle.id);</br>
                                    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * triangle.points.size(), triangle.points.data(), GL_STATIC_DRAW);</br>
                                </div>
                                Premièrement, obtenons de la part d'OpenGL une partie de mémoire, via la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml" target="_blank">glGenBuffers()</a>.
                                Son premier paramètre représente le nombre d'objets OpenGL que nous allons crée (ici, qu'un seul VBO), et le deuxième représente une référence vers un nombre (unsigned int), qui aura une valeur que nous pourrons utiliser pour accéder à cet objet OpenGL.
                                En suite, nous indiquons à OpenGL que nous allons utiliser la partie de mémoire créée comme le VBO actuellement utilisé (GL_ARRAY_BUFFER) par OpenGL grâce à la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml" target="_blank">glGenBuffers()</a>.
                                Finalement, <u>nous envoyons dans cette partie de mémoire les données du VBO</u>.
                                Pour cela, nous utilisons la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml" target="_blank">glBufferData()</a>, permettant d'envoyer des données dans une zone de mémoire OpenGL.
                                Le premier paramètre représente l'endroit où envoyer les données (ici, le VBO actuellement utilisé, défini plus haut).
                                Le deuxième paramètre représente la taille en octet de données que nous allons passer à la mémoire.
                                Nous n'allons passer que des "float" (4 octets de mémoire), autant qu'il y en a dans le vecteur des points du triangle.
                                <u>Le troisième paramètre nous permet d'indiquer les données à passer à la mémoire</u>.
                                Elle prend en paramètre un pointeur vers un tableau de données C++.
                                Ici, nous lui passons un pointeur vers les données du vecteur sous forme de tableau, grâce à la méthode "data".
                                Finalement, le dernier paramètre représente la façon dont OpenGL doit écrire les données.
                                La méthode "GL_STATIC_DRAW" est la plus rapide à utiliser, mais sera plus longue à modifier dans le futur si besoin (nous ne le ferons pas ici).
                                Pour en finir, il nous faut ajouter un moyen de supprimer les données allouées par OpenGL à la mémoire.
                                <div class="code_sample">
                                    // Libère la mémoire allouée pour le VBO</br>
                                    glDeleteBuffers(1, &triangle.id);
                                </div>
                                La fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml" target="_blank">glDeleteBuffers()</a> fonctionne de la même manière que "glGenBuffers()", vue plus haut.
                                Cette opération doit être effectuée après la boucle d'éxecution.
                                Maintenant, <span class="important">votre VBO est bien chargé dans la mémoire d'OpenGL</span>.
                            </p>
                            <p>
                                En suite, <span class="important">nous allons passer le shader vers OpenGL</span>.
                                Pour commencer, <u>il vous faudra vos deux shaders nécessaires : un vertex shader et un fragment shader</u>.
                                Nous allons simplement recopier une version simplifiée de ceux dans le cours d'introduction à OpenGL.
                                <div class="code_sample">
                                    // Vertex</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Données du VBO (vec3 représente un point 3D)</br>
                                    layout(location = 0) in vec3 pos; // Position du point P</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Calcul du point retourné par le shader</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;gl_Position = vec4(pos.xyz, 1.0);</br>
                                    }
                                </div>
                                <div class="code_sample">
                                    // Fragment</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Couleur sortie du shader</br>
                                    out vec4 FragColor;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp&nbsp;// Calcul de la couleur nécessaire, avec ici le rouge, ou RGBA(255, 0, 0, 255)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;FragColor = vec4(1, 0, 0, 1);</br>
                                    }
                                </div>
                                <span class="important">Ce code utilise un langage très proche du C : <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_blank">GLSL</a></span>.
                                Comme en C, la fonction principale du programme est "maine()", qui ne retourne rien.
                                <u>Le type vec3 correspond à un vecteur de 3 flottants et vec4 correspond à un vecteur de 4 flottants</u>.
                                Ici, le "#version 330 core" permet de spécifier la version d'OpenGL utilisé ici.
                                <u>Les variables définis avec "out" signifient que le shader retourne ces variables pour le prochain shader</u>.
                                "FragColor" représente la couleur pour le pixel traité par le shader.
                                Cependant, certaines variables sont directement incluses à OpenGL, comme "gl_Position", qui représente la position précise d'un point du VBO (que nous pouvons modifier pour bouger l'objet).
                                À l'inverse, <u>les variables définis avec "in" signifient que le shader reçoit ces variables depuis le dernier shader (ou depuis le VBO dans le cas du vertex shader)</u>.
                                Dans le vertex shader, "layout(location = x)" permet de dire à shader d'aller chercher une certains variable dans le VBO, acomme étant la "x ième" variable traitée pour un point du VBO.
                                Nous verrons comment utiliser ça précisement un peu après.
                                Plaçons ces codes dans des "std::string", que nous appellerons respectivement "vertex_shader" et "fragment_shader".
                                Ces codes vont être directement compilés par OpenGL.
                                <div class="code_sample">
                                    // Compilation du fragment shader</br>
                                    unsigned int fragment = glCreateShader(GL_FRAGMENT_SHADER);</br>
                                    char* current_shader = new char[fragment_shader.size()];</br>
                                    for(int i = 0;i&lt;fragment_shader.size();i++){current_shader[i]=fragment_shader[i];}</br>
                                    int shader_size = fragment_shader.size();</br>
                                    glShaderSource(fragment, 1, &current_shader, &shader_size);</br>
                                    glCompileShader(fragment); delete current_shader;</br></br>
                                    // Compilation du vertex shader</br>
                                    unsigned int vertex = glCreateShader(GL_VERTEX_SHADER);</br>
                                    current_shader = new char[vertex_shader.size()];</br>
                                    for(int i = 0;i&lt;vertex_shader.size();i++){current_shader[i]=vertex_shader[i];}</br>
                                    glShaderSource(vertex, 1, &current_shader, &shader_size);</br>
                                    glCompileShader(vertex); delete current_shader;
                                </div>
                                Le code est quasiment le même pour les deux shaders.
                                Nous commençons par créer un simple shader (de type GL_FRAGMENT_SHADER ou GL_VERTEX_SHADER) grâce à la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" target="_blank">glCreateShader()</a>.
                                Elle retourne ensuite un ID, qui permettra d'accéder au shader nouvellement créé.
                                En suite, <u>nous spécifions au shader nouvellement créé le code qui le constitue, grâce à <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml" target="_blank">glShaderSource()</a></u>.
                                Cette fonction prend en premier paramètre le shader à traiter (via son ID).
                                Le deuxième paramètre permet de savoir combien de shaders vont être compilés (qu'un seul ici).
                                Le troisième paramètre est assez spécial.
                                <u>Il s'agit d'un pointeur VERS un pointeur VERS le contenu du shader, sous forme de tableau de caractère</u>.
                                C'est pour cela que nous le créeons dans un nouveau tableau de caractère, grâce à "current_shader" et à la boucle.
                                Finalement, le dernier paramètre prend un pointeur vers une variable contenant la taille du shader a compilé.
                                Dés que le shader est entièrement passé, <span class="important">il est compilé avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml" target="_blank">glCompileShader()</a></span>.
                                N'oubliez pas de supprimer le tableau de caracètre crée à la fin, pour ne pas perdre d'espace mémoire.
                                Dés que cela est fait, nous devons nous assurer que rien n'est arrivé pendant la compilation.
                                <div class="code_sample">
                                    // Vérifier le fragment shader</br>
                                    int  success = 0;</br>
                                    char infoLog[512];</br>
                                    glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);</br>
                                    if (!success) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glGetShaderInfoLog(fragment, 512, NULL, infoLog);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Erreur de compilation sur le fragment" &lt;&lt; std::endl &lt;&lt; infoLog &lt;&lt; std::endl;</br>
                                    }</br></br>
                                    // Vérifier le vertex shader</br>
                                    success = 0;</br>
                                    glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);</br>
                                    if (!success) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glGetShaderInfoLog(vertex, 512, NULL, infoLog);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Erreur de compilation sur le vertex shader" &lt;&lt; std::endl &lt;&lt; infoLog &lt;&lt; std::endl;</br>
                                    }
                                </div>
                                Ici, <a href="https://registry.khronos.org/OpenGL-Refpages/es2.0/xhtml/glGetShaderiv.xml" target="_blank">glGetShaderiv()</a> permet de récupérer une information sur le shader.
                                Le premier paramètre représente le shader à tester, le deuxième représente l'information à tester, et le troisième représente une référence vers un entier contenant la réponse de la fonction.
                                Si le shader n'a pas pu être compilé, <span class="important">on cherche ce qui ne va pas grâce à la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml" target="_blank">glGetShaderInfoLog()</a></span>.
                                Son premier paramètre représente le shader à tester, le deuxième représente la taille maximale des informations sorties par la fonction, la troisième représente un pointeur vers une variable contenant la taille réelle renvoyée et la quatrième représente l'endroit où écrire l'information.
                                Nous afficheons en suite cette erreur à l'écran.
                                Si tout cela fonctionne, alors nous pouvons finir de créer notre shader.
                                <div class="code_sample">
                                    // Génération du shader dans OpenGL</br>
                                    unsigned int shader_program = glCreateProgram();</br>
                                    glAttachShader(shader_program, vertex);</br>
                                    glAttachShader(shader_program, fragment);</br>
                                    glLinkProgram(shader_program);
                                </div>
                                Nous commençons par créer un programme entier de shader via <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml" target="_blank">glCreateProgram()</a>, encore une fois sous la forme de "unsigned int".
                                Après, <span class="important">nous attachons les programmes compilés à ce programme avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml" target="_blank">glAttachShader()</a></span>.
                                Finalement, vous liez le programme final avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml" target="_blank">glLinkProgram()</a>, et le tour est joué.
                                Il reste trois dernière étapes avant d'en finir.
                                <div class="code_sample">
                                    // Vérifier le shader final</br>
                                    success = 0;</br>
                                    glGetProgramiv(shader_program, GL_LINK_STATUS, &success);</br>
                                    if (!success) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;glGetProgramInfoLog(shader_program, 512, NULL, infoLog);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Erreur de compilation" &lt;&lt; infoLog &lt;&lt; std::endl;</br>
                                    }</br></br>
                                    // Supression des ressources inutiles</br>
                                    glDeleteShader(vertex);</br>
                                    glDeleteShader(fragment);
                                </div>
                                Nous commençons par une dernière vérification du shader, puis nous supprimons les shaders compilé (le nouveau programme de shader en aura fait une copie).
                                Dés que tout cela est fait, il ne nous reste plus qu'à préciser au shaders les paramètres d'entrées du vertex shader.
                                <div class="code_sample">
                                    // Shader actuellement utilisé</br>
                                    glUseProgram(shader_program);</br></br>
                                    // Paramètre nécessaire</br>
                                    int taille_actuelle = 0;</br>
                                    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3, (void*)taille_actuelle);</br>
                                    glEnableVertexAttribArray(0);
                                </div>
                                Nous définissons "shader_program" comme le shader actuellement utilisé avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgram.xhtml" target="_blank">glUseProgram()</a>.
                                En suite, nous définissons une nouvelle entrée pour le vertex shader, via <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml" target="_blank">glVertexAttribPointer()</a>.
                                Le premier paramètre prend la position de l'entrée actuelle passée.
                                Si vous passez plusieurs entrée (ce que nous ferons plus tard), il faut mettre le nombre nécessaire pour chaque entrées.
                                Le deuxième paramètre représente le nombre de données prise par cette variable.
                                En d'autre terme, <u>il s'agit de la taille du vecteur représenté par cette variable (ou 1 si il ne s'agit pas d'un vecteur)</u>.
                                Le troisième paramètre représente le type d'un composant du vecteur, ici un "float".
                                Le quatrième paramètre indique si OpenGL doit normaliser le vecteur ou non.
                                Le cinquième paramètre représente le nombre total d'octets entre deux occurences de cette entrée dans le VBO.
                                Pour finir, le dernier paramètre représente le décalage nécessaire à partir du début de toutes les données dans un shader par rapport à la première donnée pour arriver à celle-ci.
                                En quelque sorte, <u>c'est la position de cette donnée par rapport aux autres</u>.
                                Plus précisement, il s'agit d'un pointeur vers une variable contenant cette donnée (ici taille_actuelle).
                                <span class="important">Petite précision : cette fonction nécessite que le VBO est déjà été crée et qu'il soit défini comme VBO actuel d'OpenGL : nous verrons comment bien s'organiser avec ça après</span>.
                                En suite, cette entrée (ou du moins, l'entrée ayant comme position le paramètre de la fonction) est validée au shader par <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml" target="_blank">glEnableVertexAttribArray()</a>.
                                Finalement, comme toujours, nous devons libérer la mémoire à la fin du programme.
                                <div class="code_sample">
                                    // Suppression de la mémoire</br>
                                    glDeleteProgram(shader_program);
                                </div>
                                <span class="important">Maintenant, nous pouvons utiliser ce shader</span>.
                            </p>
                            <p>
                                Finalement, <span class="important">nous allons pouvoir commencer à créer le shader</span>.
                                Cependant, cette étape va devoir reprendre toutes les étapes que nous avons vu dans cette partie.
                                Donc, <u>nous allons créer pleins de fonctions, qui reprennent tout ce que l'on n'a fait sous un seul nom</u>.
                                <ul>
                                    <li>
                                        Le chargement d'un VBO (plaçage des points dans l'espace mémoire) sera assurée par une fonction "charger_vbo".
                                    </li>
                                    <li>
                                        La création et chargement d'un shader sera assurée par une fonction "creer_shader".
                                    </li>
                                    <li>
                                        La création d'un VBO (de ces points et de son espace mémoire) sera assurée par une fonction "creer_vbo".
                                    </li>
                                    <li>
                                        La suppression d'un shader sera assurée par une fonction "supprimer_shader".
                                    </li>
                                    <li>
                                        La suppression d'un VBO sera assurée par une fonction "supprimer_vbo".
                                    </li>
                                </ul>
                                Après tout ça, votre code avant la boucle devrait ressembler à ça.
                                <div class="code_sample">
                                    // Créer le VBO</br>
                                    VBO* vbo = creer_vbo();</br>
                                    charger_vbo(vbo);</br></br>
                                    // Créer le shader</br>
                                    unsigned int shader = creer_shader();
                                </div>
                                Nous allons partir de cette base pour créer le VAO.
                                Commençons par créer le VAO dans la mémoire.
                                <div class="code_sample">
                                    // Créer le VAO</br>
                                    unsigned int vao;</br>
                                    glGenVertexArrays(1, &vao);
                                </div>
                                Ici, c'est <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml" target="_blank">glGenVertexArrays()</a> qui s'en occupe, toujours avec le système de "unsigned int".
                                Une fois le VAO crée, attachons-y le VBO, que nous créeons donc à cet instant là.
                                <div class="code_sample">
                                    // Attache du VBO</br>
                                    glBindVertexArray(vao);</br>
                                    VBO* vbo = creer_vbo();</br>
                                    charger_vbo(vbo);
                                </div>
                                <u>L'ordre d'appel est très important ici, et c'est pour ça qu'on a découpé le programme en fonctions plus précises</u>.
                                Nous commençons par fait de "vao" le VAO actuellement utilisé par OpenGL avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml" target="_blank">glBindVertexArray()</a>, puis nous créeons le VBO juste après.
                                En suite, viens la création du shader, qui doit avoir lieu après celle du VBO (comme nous avons vu plus haut).
                                <div class="code_sample">
                                    // Créer le VAO</br>
                                    unsigned int vao;</br>
                                    glGenVertexArrays(1, &vao);</br></br>
                                    // Attache du VBO</br>
                                    VBO* vbo = creer_vbo();</br>
                                    glBindVertexArray(vao);</br>
                                    charger_vbo(vbo);</br></br>
                                    // Créer le shader</br>
                                    unsigned int shader = creer_shader();
                                </div>
                                Maintenant que tout cela est fait, <span class="important">utilisons notre VAO pour effectuer un rendu fonctionnel</span>.
                                Tout ce qui va suivre doit, en toute logique, se trouver dans la boucle d'exécution.
                                <div class="code_sample">
                                    // Dessin du triangle</br></br>
                                    // Shader actuellement utilisé</br>
                                    glUseProgram(shader);</br></br>
                                    // Tracer les points via le VAO</br>
                                    glBindVertexArray(vao);</br>
                                    glDrawArrays(GL_TRIANGLES, 0, vbo->points.size() / 3.0);
                                </div>
                                Nous devons réutiliser la fonction "glUseProgram()", pour dire à OpenGL qu'on utilise ce shader.
                                En suite, nous définissons "vao" comme la VAO utilisé actuellement par OpenGL, grâce à "glBindVertexArray()".
                                Pour finir, <span class="important">le traçage des formes sur le contexte actuel est ordonné par la fonction <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" target="_blank">glDrawArrays()</a></span>.
                                Elle prend en premier paramètre le type de forme à tracer, en deuxième paramètre le décalage nécessaire de données dans le VBO pour commencer le traçage (avec ici aucun décalage), et finalement en troisième paramètre le nombre de points à tracer.
                                Théoriquement, <span class="important">votre triangle devrait être bien tracé sur votre fenêtre OpenGL</span>.
                            </p>
                            <img alt="Fenêtre OpenGL avec un triangle" src="../../images/cpp_opengl/triangle.png" style="max-height:300px;">
                        </div>
                        <h3>
                            d. Communiquer avec les objets OpenGL
                        </h3>
                        <div>
                            <p>
                                Imaginez que vous vouliez bouger votre objet.
                                Comment faire ?
                                <u>On peut penser qu'il faut agir sur le VBO, mais modifier le VBO à chaque boucle prendrait beaucoup de temps</u>.
                                <span class="important">À la place, nous allons utiliser un système permettant de communiquer de manière rapide et simple avec les shaders : les variables "uniform"</span>.
                                En effet, les variables notées "in" dans le shader ne peuvent pas être modifiée sans modifier le VBO.
                                <span class="important">Les variables "uniform" peuvent être modifiée quand vous le souhaitez depuis le programme principal</span>.
                                Pour bouger le shader, c'est ici que les mathématiques et GLM entrent en jeu.
                                En effet, notre vertex shader prend des points 3D, nous devons donc utiliser un moyen mathématique de bouger ces points 3D facilement.
                                Ici, <u>on va utiliser le système de calcul matriciel</u>.
                                Nous ne rentrerons pas dans les détails (GLM le fera pour nous), cependant les transformations que nous allons faire sont parfaitement applicables avec des matrices.
                                Nous allons appliquer des <a href="https://fr.wikipedia.org/wiki/Translation" target="_blank">translations</a>, des <a href="https://fr.wikipedia.org/wiki/Homoth%C3%A9tie" target="_blank">homothéties (remise à l'échelle, aggrandissement / rétrecissement)</a> et des <a href="https://fr.wikipedia.org/wiki/Rotation_affine" target="_blank">rotations</a>.
                                Pour cela, nous aurons besoin de matrices de dimension 4X4.
                                Ajoutons la au shader.
                                <div class="code_sample">
                                    // Vertex</br></br>
                                    // Version d'OpenGL</br>
                                    #version 330 core</br></br>
                                    // Données du VBO (vec3 représente un point 3D)</br>
                                    layout(location = 0) in vec3 pos; // Position du point P</br></br>
                                    // Données du programme principal</br>
                                    uniform mat4 transformation;</br></br>
                                    // Fonction de base du shader</br>
                                    void main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Calcul du point retourné par le shader</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;gl_Position = transformation * vec4(pos.xyz, 1.0);</br>
                                    }
                                </div>
                                En GLSL, une matrice utilise le type "mat4".
                                Pour appliquer les transformations dans le shader, nous avons juste à multiplier la matrice aux coordonnées du points.
                                Finalement, ajoutons du code au programme principal, pour appliquer des transformations.
                                Nous devons commencer par inclure les librairies GLm que nous utiliserons ici.
                                <div class="code_sample">
                                    #include &lt;glm/glm.hpp&gt;</br>
                                    #include &lt;glm/gtc/matrix_transform.hpp&gt;</br>
                                    #include &lt;glm/gtc/type_ptr.hpp&gt;
                                </div>
                                Nous pouvons maintenant commencer les choses sérieuses.
                                <div class="code_sample">
                                    // Calcul de la transformation</br>
                                    glm::mat4 transformation = glm::mat4(1);</br>
                                    // Translation de la matrice</br>
                                    transformation = glm::translate(transformation, glm::vec3(-0.5, 0, 0.2));</br>
                                    // Rotation de la matrice</br>
                                    transformation = glm::rotate(transformation, 0.5f, glm::vec3(0, 0, 1));</br>
                                    // Remise à l'échelle de la matrice</br>
                                    transformation = glm::scale(transformation, glm::vec3(0.8, 1.0, 0.4));</br></br>
                                    // Shader actuellement utilisé</br>
                                    glUseProgram(shader);</br>
                                    // Passage de la variable uniforme</br>
                                    int variable_uniform = glGetUniformLocation(shader, "transformation");</br>
                                    glUniformMatrix4fv(variable_uniform, 1, GL_FALSE, glm::value_ptr(transformation));</br></br>
                                    // Tracer les points via le VAO</br>
                                    glBindVertexArray(vao);</br>
                                    glDrawArrays(GL_TRIANGLES, 0, vbo->points.size() / 3.0);
                                </div>
                                Commençons par créer la transformation, avec une matrice 4X4, de type "glm::mat4".
                                Pour être précis, nous créeons ici une matrice diagonale (avec des 1).
                                En suite, <u>nous obtenons une matrice transformé par translation de "transformation", qui sera la nouvelle valeur de "transformation"</u>.
                                Pour cela, on utilise la fonction "translate()" de GLM, qui prend une matrice à transformer, ainsi que la translation à appliquer, et renvoie le résultat.
                                Nous faisons la même avec la rotation, grâce à la fonction "rotate()" de GLM.
                                Elle est un peu plus complexe : elle prend une matrice à transformer, ainsi qu'un angle en radians (OBLIGATOIREMENT UN "FLOAT", pas de "double" autorisé), et finalement l'axe sur lequel appliquer la rotation (ici l'axe Z).
                                En effet, en 3D, les rotations se font autour d'un axe.
                                Finalement, on utilise la fonction "scale()" de GLM, qui prend une matrice à transformer, ainsi que la remise à l'échelle à appliquer, et renvoie le résultat.
                                Dés que cela est fait, <span class="important">nous passons cette matrice au shader</span>.
                                Cette étape doit impérativement avoir lieu après "glUseProgram(shader)".
                                Pour cela, nous commençons par obtenir un "int" pour accéder à la variable uniform "transformation" du shader "shader", grâce à <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml" target="_blank">glGetUniformLocation()</a>.
                                Finalement, nous passons la variable au shader, avec <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform.xhtml" target="_blank">glUniformMatrix4fv</a>.
                                Son premier paramètre représente "l'int" d'accés à la variable.
                                Le deuxième renvoie le nombre de données qui vont être passées, et la troisième si la matrice doit être transposer (une opération matricielle, ici inutile) ou non.
                                Le dernier paramètre fourni à OpenGL un pointeur vers les données de la matrices, se trouvant à l'adresse renvoyée par "glm::value_ptr(transformation)".
                                <span class="important">Si tout est bien fait, votre triangle devrait subir ses première transformations</span>.
                                En modifiant les valeurs comme vous voulez, vous pouvez faire faire ce que vous voulez à votre triangle.
                            </p>
                            <img alt="Fenêtre OpenGL avec un triangle transformé" src="../../images/cpp_opengl/triangle_transformation.png" style="max-height:300px;">
                            <p>
                                Pour utiliser pleinement ce système, il y a quelques petits détails à rajouter.
                                Premièrement, <span class="important">vous pouvez dessiner avec un même VAO et un même shader autant que vous voulez en une fois, en modifiant seulement les variables "uniform" si vous le souhaitez</span>.
                                Par exemple, <u>vous pouvez très bien créer un "std::vector" (une liste dynamique) de différentes transformations, et toutes les dessiner à chaque fois</u>.
                                Comme ça, vous pouvez faire des choses plus complètes.
                                De plus, <span class="important">il est tout à fait possible de faire bouger (ou tourner, ou grossir / rétrécir) dans le temps des objets</span>.
                                Dans ce cas, à chaque frame, l'objet occupera une position différente.
                                Bien que vous ayez beaucoup de façon de faire, je vais vous en montrer une assez générale.
                                Première, vous aurez besoin d'un indicateur de temps, ici une fonction que nous appellerons "time_ns()", et qui renvoie le nombre de nano-secondes depuis 1970.
                                <div class="code_sample">
                                    // Retourne le nombre de nano-secondes depuis 1970</br>
                                    long long time_ns() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;timespec ts;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;clock_gettime(CLOCK_REALTIME, &ts);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;return static_cast&lt;long long&gt;(ts.tv_nsec) + static_cast&lt;long long&gt;(ts.tv_sec) * 1000000000;</br>
                                    };
                                </div>
                                À chaque début de frame, stocker le temps actuel dans une variable (de type "long long"), et comparez le avec l'ancienne valeur stockée (sauf si aucune valeur n'est déjà stockée).
                                Vous aurez la durée en nano-secondes de la dernière frame (divisez là par 1 milliard pour obtenir le temps en secondes).
                                <div class="code_sample">
                                    // Obtenir la durée en seconde de la dernière frame</br>
                                    long long temps_actuel = time_ns();</br>
                                    long long duree_frame_en_seconde = static_cast&lt;double&gt;(temps_actuel - dernier_temp) / 1000000000.0;</br>
                                    dernier_temp = temps_actuel;
                                </div>
                                Comme ça, vous saurez de quel distance l'objet à bouger PENDANT la dernière frame, ce qui vous permettra de bouger correctement l'objet.
                                En suite, vous pouvez définir une variable de type "glm::vec3" / "double" / tout ce que vous voulez, qui correspond à la position (ou rotation...) de l'objet, que vous changez à chaque frame.
                                Pour rendre vos animations plus complètes, il y a une dernière chose que vous pouvez faire.
                                <span class="important">Pour savoir quand et comment un utilisateur a intéragi avec le système d'exploitation, il existe plusieurs fonctions différentes : <a href="https://www.glfw.org/docs/3.3/group__input.html#gadd341da06bc8d418b4dc3a3518af9ad2" target="_blank">glfwGetKey()</a> pour les touches du clavier, ou même <a href="https://www.glfw.org/docs/3.3/input_guide.html#input_mouse_button" target="_blank">glfwGetMouseButton()</a> pour les touches de la souris</span>.
                                Comme ça, vous pouvez faire à ce que la réaction de l'objet dépende des entrées de l'utilisateur.
                                <div class="code_sample">
                                    // Obtenir l'état de la touche "A" du clavier</br>
                                    int touche_a = glfwGetKey(window, GLFW_KEY_A);</br>
                                    if (touche_a == GLFW_PRESS) {std::cout &lt;&lt; "La touche A est pressée." &lt;&lt; std::endl; }</br></br>
                                    // Obtenir l'état de la touche gauche de la souris</br>
                                    int etat_souris_gauche = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT);</br>
                                    if (etat_souris_gauche == GLFW_PRESS) {std::cout &lt;&lt; "La touche gauche de la souris est pressée." &lt;&lt; std::endl; }
                                </div>
                                Petit bonus : voici le VBO nécessaire pour réaliser un carré.
                                <div class="code_sample">
                                    // Création du VBO nécessaire</br>
                                    VBO triangle;</br></br>
                                    // Création d'un triangle</br>
                                    vbo->points.push_back(-0.5);vbo->points.push_back(0.5);vbo->points.push_back(0);</br>
                                    vbo->points.push_back(-0.5);vbo->points.push_back(-0.5);vbo->points.push_back(0);</br>
                                    vbo->points.push_back(0.5);vbo->points.push_back(-0.5);vbo->points.push_back(0);</br>
                                    vbo->points.push_back(0.5);vbo->points.push_back(0.5);vbo->points.push_back(0);</br>
                                    vbo->points.push_back(-0.5);vbo->points.push_back(0.5);vbo->points.push_back(0);</br>
                                    vbo->points.push_back(0.5);vbo->points.push_back(-0.5);vbo->points.push_back(0);
                                </div>

                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/saasf" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>