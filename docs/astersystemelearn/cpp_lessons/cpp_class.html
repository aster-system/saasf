<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - Hub</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <img alt="Logo de SAASF" src="../../images/logo.png"/>
            <nav>
                <div>
                    <a>
                        Lycée
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
                <div>
                    <a>
                        Aster Système Learn
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
            </nav>
        </header>
        <div id="main_div">
            <h1>
                II - 2. Les classes et objets en C++
            </h1>
            <div>
                Après 7 cours de C++, ne pas avoir parler une seule fois des classes et objets en C++ en profondeur peut être considéré comme un crime contre le C++.
                En effet, ce concept fait toute la beauté du C++, ainsi que pourquoi ce langage est si populaire.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Créer votre propre type en C++
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <h3 id="part_A_a">
                            a. Qu'est ce qu'est une classe ?
                        </h3>
                        <div>
                            <p id="part_A_a_1">
                                Comme je l'ai déjà écrit, <u>le C++ est découpé en plusieurs types différents, certains primaires, et d'autres non</u>.
                                <span class="important">Parmis les types non primaires, il existe un moyen de créer votre propre type, grâce au système de classe</span>.
                                <u>Le système de classe permet de définir toutes les règles du type que vous voulez créer</u>.
                                Sans le savoir, nous avons déjà utilisé des types crées avec des classes, comme "std::string" ou "std::vector".
                            </p>
                            <p id="part_A_a_2">
                                <span class="important">Le système de classe s'inclut dans le seul paradigme du C++ que nous n'avons pas étudié pour l'instant : <a href="https://fr.wikipedia.org/wiki/Programmation_orient%C3%A9e_objet">la programmation orientée objet</a> (que nous appellerons POO à partir de maintenant)</span>.
                                Ce paradigme est un des paradigmes de programmation les plus importants qu'il existe.
                                <u>Il définit de manière très precise et pratique le fonctionnement du système de classe</u>.
                                Il définit plusieurs concepts très importants, que nous aborderons petit à petit : <span class="important">l'abstraction, l'encapsulation, l'instanciation, le polymorphisme...</span>.
                            </p>
                            <p id="part_A_a_3">
                                <span class="important">En C++, la déclaration d'une classe se fait très simplement :</span>
                                <div class="code_sample">
                                    class Nom_De_La_Classe {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Contenu de la classe</br>
                                    };
                                </div>
                                À noter que, <u>en général, les mots dans les noms de classes commencent par des lettres majuscules</u>.
                                Il faut aussi ne pas oublier le point virgule après les accollades.
                                Tout ce qui sera dans la classe appartiendra d'ailleurs à l'espace de nom "Nom_De_La_Classe", crée automatiquement (même si, pour des raisons que nous verrons plus tard, savoir ça n'est pas très important).
                                <u>Pour créer une variable du type de la classe, il faut le créer comme n'importe qu'elle autre variable</u> :
                                <div class="code_sample">
                                    Nom_De_La_Classe une_variable;
                                </div>
                                <span class="important">Une variable qui a pour type une classe est nommée une instance de la classe, ou, plus communément, un objet</span>.
                            </p>
                            <p id="part_A_a_4">
                                Il y a cependant un autre moyen de faire, légèrement différent.
                                <span class="important">En effet, on peut aussi déclarer une classe avec le mot clé "struct" à la place de "class"</span>.
                                Pour comprendre la différence entre les deux, <u>il faut que nous attendions de voir le principe d'encapsulation</u>.
                            </p>
                            <p id="part_A_a_5">
                                <u>Pour pouvoir être utilisée, la classe peut contenir des variables ou bien des fonctions, utilisables sur une instance ou sur la classe en général</u>.
                                <span class="important">Les variables contenues dans une instance sont nommées des attributs, et les fonctions utilisables via l'instance sont nommées des méthodes</span>.
                                Elles sont accessibles via l'opérateur d'accès aux membres "." appliqué sur l'instance à utiliser.
                                Nous avons déjà utilisé quelques méthodes, dans "std::string" ou dans "std::vector", comme :
                                <div class="code_sample">
                                    // Ligne à ajouter pour utiliser des vecteurs</br>
                                    #include &lt;vector&gt;</br>
                                    #include &lt;iostream&gt;</br></br>
                                    using namespace std;</br></br>
                                    int main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;int&gt; tableau_2(5, 1); // Créer un autre vecteur de nombre entier "int" contenant 5 fois le nombre 1</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tableau_2.push_back(10); // Utilisation de la méthode "push_back", pour rajouter "10" au tableau dynamique "tableau_2".</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    }
                                </div>
                            </p>
                        </div>
                        <h3 id="part_A_b">
                            b. Les méthodes et attributs de classe
                        </h3>
                        <div>
                            <p id="part_A_b_1">
                                <span class="important">Les attributs de classes doivent être définies dans la classe, comme des variables normales</span> :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                                Dans cette exemple, je définis "a_age" à 40, qui sera la valeur pas défaut pour chaque instance de la classe, tant qu'elle ne sera pas modifiée.
                                Il est conseillé d'ajouter "a_" au début des noms d'attributs, "a_" comme "attribut", pour les différencier des autres variables.
                                Il est important de noter que l'ordre dans lequel est écrit les attributs et méthodes n'influent en rien dans la classe, les attributs étant toujours déclarés avant par le compiler.
                            </p>
                            <p id="part_A_b_2">
                                <span class="important">Les méthodes de classes doivent être définies dans la classe, comme des fonctions normales</span> :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Méthode permettant d'afficher l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void show_age() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "This person is " &lt;&lt; a_age &lt;&lt; " years old." &lt;&lt; endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                                Les attributs sont directement utilisables dans les méthodes.
                                <u>Il est possible de définir des méthodes constantes avec "const", si elles ne modifient pas directement l'objet</u>, comme pour "show_age" :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Méthode non-constante permettant de modifier l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void set_age(unsigned int new_age) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_age = new_age;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Méthode constante permettant d'afficher l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void show_age() const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "This person is " &lt;&lt; a_age &lt;&lt; " years old." &lt;&lt; endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                                <u>Seules les méthodes "const" peuvent être utilisées sur une instance constante de la classe</u>.
                                Chaque classe contient quelques méthodes de bases, que nous examinerons plus tard.
                                <u>Parmis toutes les méthodes de bases, il y en a deux très spéciales et importantes : le constructeur et le destructeur de classe</u>.
                            </p>
                            <p id="part_A_b_3">
                                Parmis les méthodes spéciales, <span class="important">le constructeur de classe est une méthode appelé lors de la création d'une instance, et le destructeur est appelé lors de sa destruction</span>.
                                Elles ne retournent rien, même pas "void", et se définissent comme ça :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person(unsigned int age) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// L'age est modifié directement lors de la création de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_age = age;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                                Les paramètres passés au constructeur doivent être utilisé lors de la création de l'instance :
                                <div class="code_sample">
                                    // Création d'une personne de 17 ans</br>
                                    Person person_1(17);</br></br>
                                    // Autre manière d'utiliser le constructeur, ici pour créer une personne de 41 ans</br>
                                    Person person_2 = Person(41);
                                </div>
                                Il est d'ailleurs possible de modifier une valeur via le constructeur de manière encore plus direct :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person", modifiant directement la valeur de l'age</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person(unsigned int age) : a_age(age) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                                Cette façon de faire est obligatoire pour définir les attributs constants.
                                Vous pouvez aussi déclarer plusieurs constructeurs différents selon leurs paramètres, qui peuvent même s'appeler entre eux, de la même façon que la définition directe des variables :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person", modifiant directement la valeur de l'age</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person(unsigned int age) : a_age(age) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person", utilisant un age par défaut et le passant à un autre constructeur</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person() : Person(40) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                                Les deux constructeurs sont utilisables dans les instances :
                                <div class="code_sample">
                                    // Création d'une personne de 17 ans</br>
                                    Person person_1(17);</br></br>
                                    // Création d'une personne sans age spécifié, qui sera donc de 40 par défaut</br>
                                    Person person_2;
                                </div>
                            </p>
                            <p id="part_A_b_4">
                                À l'inverse, <span class="important">le destructeur fonctionne de la même manière, mais est appelé lorsque que l'instance est supprimée</span>.
                                <u>L'instance est automatiquement supprimée par le programme quand on arrive à la fin de sa zone de définition, pour gagner de la mémoire</u>.
                                Il se définit comme le constructeur, avec juste une vaguelette espagnole "~" devant le nom de classe :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person(unsigned int age) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// L'age est modifié directement lors de la création de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_age = age;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Destructeur de la classe "Person"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~Person() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Supression d'une instance" &lt;&lt; endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                            </p>
                            <p id="part_A_b_5">
                                En général, <span class="important">il est grandement conseillé de déclarer les classes dans un fichier header, et de définir les méthodes dans un fichier source</span>.
                                Pour cela, <u>les méthodes dans la déclaration doivent être dépourvues de définitions (donc, des accolades et de leur contenu), mais terminées par un point virgule ";"</u>.
                                Pour définir les méthodes dans le fichier source, ils ne faut pas oublier de spécifier l'espace de nom de la classe, avec "Nom_De_La_Classe::nom_de_la_methode".
                                Voici ce que cela donne pour notre classe "Person" :
                                <div class="code_sample">
                                    // Fichier header "person.h"</br></br>
                                    #ifndef PERSON</br>
                                    #define PERSON</br></br>
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person(unsigned int age);</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Destructeur de la classe "Person"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~Person();</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Affichage l'age de la "Person" (méthode constante)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void show_age() const;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };</br></br>
                                    #endif // PERSON
                                </div>
                                <div class="code_sample">
                                    // Fichier source "person.cpp"</br></br>
                                    #include &lt;iostream&gt;</br>
                                    #include "person.h"</br></br>
                                    // Constructeur de la classe "Person"</br>
                                    Person::Person(unsigned int age) : a_age(age) {}</br></br>
                                    // Destructeur de la classe "Person"</br>
                                    Person::~Person() {}</br></br>
                                    // Affichage l'age de la "Person" (méthode constante)</br>
                                    void Person::show_age() const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "This person is " &lt;&lt; a_age &lt;&lt; " years old." &lt;&lt; endl;</br>
                                    }
                                </div>
                                Les attributs sont automatiquement définis en même temps que l'instance de classe, donc pas besoin de le faire soit même.
                                Dans le cas où l'on crée un fichier source et un fichier header, <u>nous économisons du temps de compilation et de taille de fichiers objets</u>.
                                Dans le cas contraire, nous faisons comme pour les fonctions statiques du dernier cours (une copie de la fonction par fichiers objets).
                                Pour ne pas avoir à créer trop de fichiers différents, nous allons partir du principe que notre classe est entièrement déclarée et définie dans un fichier source, à partir de maintenant (où la combinaison des deux façons de faire, directement ou après, est possible).
                            </p>
                            <p id="part_A_b_6">
                                Pour finir, <u>nous allons voir deux mots clés assez importants, que nous avons déjà vu, mais qui ont des propriétés différentes pour les classes : inline et static</u>.
                                <span class="important">Une méthode déclarée avec "inline" est une méthode qui peut avoir ses appels dans le code remplacés par son code source assembleur</span>.
                                <u>C'est légèrement plus rapide, mais ça prend plus de place en code assembleur, car la définition du code inline doit être obligatoirement juste après sa déclaration (pas de séparation en plusieurs fichiers possibles ici)</u>.
                                En général, c'est grandement utilisé pour les petites fonctions très utilisées, comme les getters et setters.
                                <span class="important">Une méthode déclarée avec "static" est une méthode qui n'est pas faite pour être utilisée sur une instance de classe, mais sur la classe toute entière</span>.
                                Son appel ce fait donc comme ça : "Nom_De_La_Classe::nom_de_la_methode", sans possibilité de l'utiliser avec une instance.
                                <span class="important">À l'instar des méthodes statiques, les attributs déclarés avec "static" sont des attributs qui n'appartiennent pas à une instance, mais à toute la classe</span>.
                                Cependant, à l'inverse des méthodes inline, <u>elles doivent être définies dans un fichier source, comme les variables statiques hors d'une classe</u>.
                                Une utilité de ses attributs est de compter le nombre d'instances d'une classe créees, en ajoutant un au nombre à chaque nouvelle instance, directement dans le constructeur.
                            </p>
                        </div>
                        <h3 id="part_A_c">
                            c. Le principe d'encapsulation
                        </h3>
                        <div>
                            <p id="part_A_c_1">
                                Avant de pouvoir utiliser pleinement notre classe, <u>il nous manque un principe extrêmement important : l'encapsulation</u>.
                                En effet, avec les méthodes, <span class="important">chaque instance de classe peut avoir une interface simple de gestion de l'instance, sans passer par les attributs</span>.
                                Par exemple, des opérations complexes sur les attributs peuvent être directement gérées via des méthodes, ce qui rend l'utilisation de la classe très simple pour l'utilisateur.
                                <span class="important">Ce principe de simplification de l'utilisation de classe est nommé le principe d'encapsulation : ne rendre accessible que ce qui est nécessaire, et laisser le reste encapsuler dans la classe</span>.
                            </p>
                            <p id="part_A_c_2">
                                <u>Pour séparer ce que vous voulez rendre accessible dans la classe et ce que vous ne voulez pas rendre accessible, il existe trois mots clés : "public", "protected" et "private"</u>.
                                <span class="important">Tout ce qui est déclaré après "public" est accessible via une instance, tandis que ce qui est déclaré après "private" ne l'est pas hors des méthodes de classes</span>.
                                Cependant, cela ne change rien pour les définitions de méthodes.
                                "protected" est utilisé pour les classes héritées, que nous verrons plus tard.
                                En général, <u>les attributs sont toujours "private"</u>.
                                Par défaut, si aucun des mots clés n'est présent, tout ce qui se situe dans une classe est "private".
                                C'est d'ailleurs la différence entre une classe définit avec "class", et une définie avec "struct", car, dans struct, si aucun des mots clés n'est présent, tout ce qui se situe dans une classe est "public".
                            </p>
                            <p id="part_A_c_3">
                                <span class="important">Pour accéder aux attributs, il faut passer par des méthodes spéciales, souvent appelées "getters" et "setters"</span>.
                                <u>Les getters doivent retourner la valeur d'un attribut dans une instance de classe</u>.
                                En général, il est conseillé de les déclarer "const".
                                Elles prennent habituellement, soit le nom de l'attribut, soit "get_" suivi du nom de l'attribut.
                                <u>Les setters doivent permettre de modifier la valeur d'un attribut dans une classe</u>.
                                Généralement, elles commencent par "set_" pour se démarquer des autres méthodes.
                                L'avantage est d'avoir une interface pour la modification ou la récupération d'un attribut, permettant de rendre tout cela plus modulable.
                            </p>
                            <p id="part_A_c_4">
                                En respectant tout ça, nous pouvons re-définir notre classe "Person" :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person", modifiant directement la valeur de l'age</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person(unsigned int age) : a_age(age) {};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person", utilisant un age par défaut et le passant à un autre constructeur</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person() : Person(40) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Destructeur de la classe "Person"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~Person() {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Retourne l'age de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inline unsigned int age() const { return a_age; };</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Modifie l'age de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inline void set_age(unsigned int new_age) { a_age = new_age; };</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                            </p>
                        </div>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_B">
                        B. Le polymorphisme et l'héritage
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <h3 id="part_B_a">
                            a. Quand une classe... peut en être une autre
                        </h3>
                        <div>
                            <p id="part_B_a_1">
                                Comme je l'ai déjà écrit, <u>le C++ est découpé en plusieurs types différents, certains primaires, et d'autres non</u>.
                                Cependant, <u>un type peut contenir des données parfaitement similaires à un autre, par exemple si l'un est juste une version spécifique de l'autre</u>.
                                Par exemple, notre type "Person" représente une personne quelconque, et contient des données sur cette personne.
                                Cependant, un potentiel type "Developer" devrait contenir des informations sur le métier du dévelopeur, mais aussi sur la personne qu'est le développeur, déjà contenu dans "Person".
                                <span class="important">Le système de classe offre un moyen de créer un type dérivant d'un autre, grâce au système de polymorphisme</span>.
                                Avec ça, on peut créer notre classe "Developer", contenant ses propres attributs et membres, mais aussi ceux de "Person".
                                Dans ce cas, <span class="important">une instance de "Developer" pourra être interprétée comme un instance de "Person" par le compiler (même si l'inverse n'est pas vraie)</span>.
                                Quand une classe "B" dérive d'une classe "A", <u>on dit que la classe "B" est héritée de "A", et que "A" est la classe parent de "B"</u>.
                                Ce système marche autant de fois qu'on ne le veut, avec par exemple la classe "C" qui hérite de "B", "D" qui hérite de "C"...
                                Toutes hériteront de "A", toutes sauf "B" hériteront de "B", toutes sauf "B" et "C" hériteront de "C"...
                            </p>
                            <p id="part_B_a_2">
                                Pour qu'une classe hérite d'une autre, la syntaxe est très simple :
                                <div class="code_sample">
                                    class Developer : public Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un développeur, héritant de "Person"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Developer", modifiant directement la valeur de l'age et du language</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Developer(unsigned int age, std::string language) : Person(age), a_language(language) {};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Developer", utilisant un age et un language par défaut et le passant à un autre constructeur</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Developer() : Developer(40) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Destructeur de la classe "Developer"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~Developer() {};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "std::string", contenant le language pratiqué par le développeur</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string a_language = "C++";</br>
                                    };
                                </div>
                                Il suffit de rajouter ": public Classe_Parent" après le "class Nom_De_La_Classe".
                                Nous verrons les propriétés du mot "public" ici dans quelques instants.
                                <span class="important">Il est à noter ici que, dans le constructeur de "Developer", on appelle le constructeur de la classe parent "Person", pour directement construire la partie "Person" de "Developer"</span>.
                            </p>
                            <p>
                                <span class="important">L'énorme avantage du polymorphisme est la possibilité d'utiliser une instance de "Developer" comme une instance de "Person", par exemple comme ça</span> :
                                <div class="code_sample">
                                    // Fonction qui retourne si une personne est majeure ou pas</br>
                                    bool is_major(const Person& person) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return person.age() >= 18;</br>
                                    };</br></br>
                                    // Fonction main du programme</br>
                                    int main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Developer dev(14, "Javascript");</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(is_major(dev)) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "This developer is major." &lt;&lt; std::endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "This developer is minor." &lt;&lt; std::endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    };
                                </div>
                                En effet, <u>"Developer" héritant de "Person", on peut très bien l'utiliser comme une "Person", permettant de créer un type global pour certaines actions, qu'on peut spécialiser en sous-types pour d'autres actions</u>.
                                <span class="important">Cela est possible grâce à un procédé nommé l'héritage des membres</span>.
                            </p>
                        </div>
                        <h3 id="part_B_b">
                            b. L'héritage des membres de classe
                        </h3>
                        <div>
                            <p id="part_B_b_1">
                                Comment ce fait-il que, dans l'exemple précédent, j'ai pu utiliser la méthode "age" de "Developer", alors qu'elle n'ai pas déclaré dans la classe "Developer" ?
                                La réponse : <span class="important">une classe qui hérite d'une autre hérite aussi de ses méthodes et attributs</span>.
                                <u>Ils sont donc utilisables dans la classe qui hérite d'eux</u>.
                                En fait, <u>je n'ai pas utiliser la méthode "age" de "Developer", mais celle de "Person", puis ce que "Developer" a hérité de tout le nécessaire pour l'utiliser</u>.
                                C'est d'ailleurs pour cela qu'on peut aussi utiliser le constructeur de "Person" dans celui de "Developer".
                            </p>
                            <p id="part_B_b_2">
                                Malgré tout cela, <u>il faut garder en tête le principe d'encapsulation, qui joue un rôle très important ici aussi</u>.
                                En effet, <span class="important">le petit mot entre le ":" et le nom de la classe parent représente la façon dont les méthodes définis publics dans la classe parent vont être dans la classe enfant</span>.
                                En général, il s'agit de "public", permettant un accés public aux méthodes publics du parent.
                                De plus, <span class="important">tout ce qui est défini en tant que "private" dans la classe parent n'est pas accessible dans la classe enfant (bien qu'elle en hérite bel et bien), de quelque manière que ce soit</span>.
                                <u>Il est cependant possible de passer outre ce problème avec le mot clé "protected", déjà mentionné un peu plus haut</u>.
                                <span class="important">Tout ce qui est défini en tant que "protected" dans la classe parent est accessible dans ses classes enfants en tant que "private"</span>.
                                Grâce à tout cela, le principe d'encapsulation est respecté sans problèmes.
                            </p>
                        </div>
                        <h3 id="part_B_c">
                            c. L'abstraction de méthodes en C++
                        </h3>
                        <div>
                            <p id="part_B_c_1">
                                Si l'héritage de méthode ne semble pas assez puissant comme ça, <u>on peut encore le rendre plus puissant, avec le concept d'abstraction</u>.
                                <span class="important">L'abstraction est un principe permettant de définir (ou re-définir) une méthode héritée différement dans une classe enfant</span>.
                                L'avantage de ce principe est que, <u>pour une instance d'une classe enfant, quelque soit la manière dont la méthode est appelée, la méthode de la classe enfant a lieu à la place de celle de la classe parent</u>.
                                Un exemple d'utilisation est de créer une méthode générale pour une classe parente de plein d'autres classes, et de pouvoir re-définir les méthodes dans les classes enfants pour ne pas avoir à créer plein de méthodes différentes et complexes sans intêret.
                                <span class="important">Il existe cependant un moyen d'appeller la méthode défini comme dans la classe parent, en utilisant la syntaxe "Nom_De_La_CLasse_Parent::methode"</span>.
                                Comme ça, vous pouvez définir un comportement générale et nécessaire dans la classe parent, et spécifier les comportements dans les classes enfants.
                            </p>
                            <p id="part_B_c_2">
                                Cependant, cela n'est pas possible avec toutes les méthodes.
                                En effet, <span class="important">cela n'est possible qu'avec un certain type de méthodes de la classe parent, nommées les méthodes virtuels</span>.
                                <u>Elles se définissent avec le mot clé "virtual" écrit avant le nom de la fonction</u> :
                                <div class="code_sample">
                                    class Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une personne</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Person", modifiant directement la valeur de l'age</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person(unsigned int age) : a_age(age) {};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Destructeur de la classe "Person"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~Person() {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Retourne le travail de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual std::string job() const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string("Unknown");</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "unsigned int", contenant l'âge de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int a_age = 40;</br>
                                    };
                                </div>
                                Comme ça, on peut faire dans la classe enfant :
                                <div class="code_sample">
                                    class Developer : public Person {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un développeur, héritant de "Person"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Developer", modifiant directement la valeur de l'age et du language</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Developer(unsigned int age, std::string language) : Person(age), a_language(language) {};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Destructeur de la classe "Developer"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~Developer() {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Retourne le travail de la personne</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual std::string job() const override {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return std::string(a_language + " developer");</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attribut de type "std::string", contenant le language pratiqué par le développeur</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string a_language = "C++";</br>
                                    };
                                </div>
                                Dans ce cas exact, un attribut "protected" suffirait, mais une méthode virtuelle aussi.
                                Cependant, <u>la réalisation du travail demandant des actions différentes par classe nécessiterait impérativement une méthode virtuelle</u>.
                                À noter qu'une classe virtuelle ne peut pas être inline ou statique.
                                D'ailleurs, le mot "override" n'est pas obligatoire, mais juste là pour détecter les méthodes héritées de méthodes virtuelles de classes parents (je ne l'utiliserai pas dans la suite du cours).
                                <u>Faite attention à bien vérifier la syntaxe de ce genre de méthode, pour qu'elles soient exactement similaires, pour éviter les erreurs ou comportements inatendus</u>.
                            </p>
                            <p id="part_B_c_3">
                                D'ailleurs, <span class="important">une des méthodes spéciales que nous avons vu doit toujours être virtuelle : le destructeur</span>.
                                En effet, quand vous voulez détruire une instance, si qu'une partie de la destruction a lieu, alors vous pourriez avoir des bugs de mémoire.
                                <u>Avec un destructeur virtuel, tous les destructeurs de toutes les classes parents sont appelé automatiquement (pas besoin de les appeler manuellement)</u>.
                                <span class="important">Donc, le destructeur doit toujours être virtuel, le compiler s'occupera du reste.</span>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <div>
                Voici donc les bases des classes en C++.
                D'autres choses sont possibles avec elles, que nous analyseront dans de prochains cours.
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/aster-school" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>
