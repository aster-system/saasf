<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - C++ II-5</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <img alt="Logo de SAASF" src="../../images/logo.png"/>
            <nav>
                <div>
                    <a>
                        Lycée
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
                <div>
                    <a>
                        Aster Système Learn
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
            </nav>
        </header>
        <div id="main_div">
            <h1>
                II - 5. Manier les type dans leur intégralité
            </h1>
            <div>
                Nous n'en avons pas fini des types et de leur maniement.
                En effet, il y a encore des choses plus secondaires à dire, bien que très pratique dans beaucoup de cas.
                Nous allons en finir avec eux dans ce cours, via tous les paradigmes que nous avons vu jusque ici.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Étendre leur utilisation
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Cette partie est axée réalisation de types via les classes, bien qu'elle pérsente aussi bien une partie de leur utilisation hors des classes.
                        <h3 id="part_A_a">
                            a. Les opérateurs de classes
                        </h3>
                        <div>
                            <p id="part_A_a_1">
                                Nous avons déjà parlé des opérateurs il y a bien longtemps, avec le cours <a href="./cpp_variables.html">sur les variables</a>.
                                Par exemple, nous pouvons écrire "int a = 5 + 8;".
                                En effet, <u>le C++ convertit cela en code assembleur permettant une addition de deux nombres</u>.
                                Cependant, nous pouvons aussi faire "std::string a = "Hello"; std::string b = " world !";".
                                La question ici est comment le C++ utiliser l'opérateur "+" avec des valeurs qui ne sont pas des nombres ?
                                La réponse est simple : <span class="important">nous pouvons définir dans une classe la façon dont une instance va réagir avec un opérateur</span>.
                                C'est grâce à ça que des sommes de string donne des strings plus long.
                            </p>
                            <p id="part_A_a_2">
                                En fait, <span class="important">ces opérateurs appellent des fonctions spéciales dans les classes, que nous pouvons donc réecrire via le principe d'héritage (voir <a href="./cpp_class.html">le cours sur les classes</a>)</span>.
                                <u>Cette opération est nommée la surchage d'opérateurs</u>.
                                Dans le cas des opérateurs simples "+", "-", "*" et "/", la fonction en question est très simple :
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur +</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex operator+(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real() + other_complex.real(), imaginary() + other_complex.imaginary());</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur -</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex operator-(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real() - other_complex.real(), imaginary() - other_complex.imaginary());</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Cette syntaxe marche aussi avec les opérateurs "*" et "/", mais je vous épargne leur implémentation avec des nombres complexes.
                                Ici, les fonctions effectuent les opérations sur une nouvelle instance de complexe, et retourne la résultat (qui sera interprété comme le résutlat de l'opérateur).
                                La fonction n'a pas besoin d'être modifié ici, elle peut être notée constante.
                                Vous pouvez maintenant faire des opérations simples avec les classes.
                            </p>
                            <p id="part_A_a_3">
                                Vous pouvez aussi magnier d'autres opérateurs, <span class="important">comme les opérateurs d'assignement</span>.
                                <u>Il peut s'agir de n'importe quel opérateur contenant un "=", comme "+=" ou "/="</u>:
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur +=</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;void operator+=(Complex other_complex) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_real += other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_imaginary += other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur -=</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;void operator-=(Complex other_complex) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_real -= other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_imaginary -= other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, ils modifient l'instance, et donc ne sont pas constants.
                                De plus, il n'ont (en général) pas besoin de retourner quoi que ce soit, donc ils ne retournent rien.
                            </p>
                            <p id="part_A_a_4">
                                <span class="important">Les derniers types d'opérateurs surchageables très utilisés sont les opérateurs de comparaisons</span>.
                                Leur fonctionnement reste très similaire:
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ==</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator==(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() == other_complex.real() && imaginary() == other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator>(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() > other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, ils ne modifient pas l'instance, et donc peuvent être constants.
                                Ils retournent le résultat de l'opération, sous forme de booléen, de manièr extrêmement similaire aux opérateurs vus plus haut.
                                Il est cependant à noter que dire qu'un nombre complexe est plus grand qu'un nombre est superflu, mais par soucis de simplicité, on va dire que, ici, un nombre complexe est plus grand si sa partie réelle est plus grande (s'il vous plait les professeurs de maths, ne me tapez pas).
                            </p>
                            <p id="part_A_a_5">
                                Une fois que vous compris le fonctionnement de ces fonctions, <span class="important">vous pouvez créer l'opérateur que vous voulez, selon le même principe</span>.
                                Voici quelques exemples d'opérateurs (très aléatoire et peu adaptés à une classe complexe, mais là pour l'exemple):
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur []</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double operator[](unsigned int index) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(index == 0) return real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ()</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator->(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() > other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, l'opérateur "()" est un opérateur utilisable sur une instance (pas une fonction, mais une instance), pour lui faire faire ce que l'on veut.
                                C'est d'ailleurs l'opérateur utilisé pour la génération de nombres aléatoires, vu dans le cours <a href="./cpp_algorithm_data_structure.html">sur les algorithmes</a>.
                                Les possibilités sont infinies.
                            </p>
                            <p id="part_A_a_6">
                                <span class="important">Une dernière façon de faire est la définition de fonction d'opérateurs hors d'une classe</span>.
                                Ce cas est utile par exemple pour pouvoir utiliser une classe avec "std::cout" et l'opérateur "&lt;&lt;", ou pour utiliser un "int" avant un opérateur quelconque.
                                En effet, <u>chaque fonction d'opérateur peut en fait être surcharger hors de la classe (c'est moins intuitif, mais nécessaires dans certains cas)</u>.
                                <u>La valeur / type du premier opérande est donc spécifié en 1er paramètre de la fonction, et la valeur / type du second opérande est le deuxième paramètre (l'ordre à un sens très important ici)</u>:
                                <div class="code_sample">
                                std::ostream& operator&lt;&lt;(std::ostream& os, Complex c) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet de "std::cout" un "Complex"</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return os &lt;&lt; c.real() &lt;&lt; " + " &lt;&lt; c.imaginary() &lt;&lt; " * i";</br>
                                }</br></br>
                                Complex operator+(int n, Complex c) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet d'additioner un "int" avec un "Complex"</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return Complex(c.real() + n, c.imaginary());</br>
                                }</br>
                                Complex operator+(Complex c, int n) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet d'additioner un "Complex" avec un "int" (exactement pareil à la fonction définie dans la classe)</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return Complex(c.real() + n, c.imaginary());</br>
                                }
                                </div>
                                D'ailleurs, il faut savoir que "std::cout" est l'instance (globale) d'une classe <a href="https://en.cppreference.com/w/cpp/io/basic_ostream" target="_blank">"std::ostream"</a>, ici utilisable via la référence "os" (que l'on doit d'ailleurs retourner juste après).
                                Faite bien attention à l'ordre, et rendez vous la vie plus facile avec ces systèmes.
                            </p>
                        </div>
                        <h3 id="part_A_b">
                            b. Les conversions de types
                        </h3>
                        <div>
                            <p id="part_A_b_1">
                                Pour rappel, <u>il existe une aberrante quantité de façon de typer un nombre : int, double, long</u>...
                                Cependant, <u>il n'y a pas de problème à convertir un int en double, (ou un double en int), avec une simple assignation</u>.
                                Nous avons pourtant vu dans le <a href="./cpp_variables.html">cours sur les variables</a> que les doubles ne sont pas représentés en binaire de la même façon que les int, un changement de forme doit donc être fait.
                                <span class="important">L'opération de transformer une donnée d'une certaine forme en une donnée d'une autre forme (mais d'inteprération similaire), et donc d'un autre type est nommée la conversion de type</span>.
                                Dans le cas des nombres, <u>cette opération est effectuée automatiquement par le compiler (c'est ce que l'on appelle une conversion implicite)</u>.
                                De plus, il y a plusieurs moyens de faire cette conversion, que allons voir tout de suite.
                            </p>
                            <p id="part_A_b_2">
                                <span class="important">Les autres types de conversions sont appellées conversions explicites</span>.
                                La façon la plus simple de convertir explicitement un type est d'utiliser des parenthèses avec le type nécessaire, avant la valeur à convertir:
                                <div class="code_sample">
                                    int entier = 6;</br>
                                    double decimal = (double)entier;
                                </div>
                                Ici, on prend la valeur de "entier", on obtient sa valeur en double, et on l'assigne dans "decimal".
                                Cependant, <u>la façon dont fonctionne cette conversion dépend du type, car il y a en effet plusieurs types de conversion possibles</u> (le compiler choisit la plus adaptée lors de la compilation).
                            </p>
                            <p id="part_A_b_3">
                                Cette méthode reste imprécise, puis ce qu'elle nous permet pas de spécifier très précisément le type de conversion.
                                Pour effectuer une conversion de manière plus précise, <span class="important">il faut utiliser un opérateur de conversion</span>.
                                <span class="important">Le plus utilisé est l'opérateur "static_cast&lt;nouveau_type&gt;(variable_a_convertir)"</span>.
                                <u>Il demande au compiler d'aller chercher dans le type de la variable à convertir un moyen de conversion vers le type demandé</u>.
                                Pour cela, <u>il cherche une surchage de deux méthodes très précises : la méthode de l'opérateur "operator nouveau_type()" et les constructeurs des conversions</u>.
                                Ma méthode "operateur" retourne une instance du type final de la conversion, qui peut s'interpréter comme l'instance utilisée pour la conversion.
                                Le constructeur converti une valeur donnée d'un certain type, directement vers l'instance.
                                Voici un exemple d'utilisation de ces méthodes :
                                <div class="code_sample">
                                    class Fraction {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une fraction</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Fraction(double numerator, double denominator) : a_denominator(denominator), a_numerator(numerator) {};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de conversion (long long vers Fraction)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Fraction(long long numerator) : Fraction(numerator, 1) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline long long denominator() const {return a_denominator;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline long long numerator() const {return a_numerator;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur de conversion vers "double"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;operator double() const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return numerator() / denominator();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Dénominateur de la fraction</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;long long a_denominator = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Numérateur de la fraction</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;long long a_numerator = 0;</br>
                                    };
                                </div>
                                Donc, une bonne utilisation de "static_cast" pour tout cela serai :
                                <div class="code_sample">
                                    Fraction f(54, 65);</br>
                                    double to_double = static_cast&lt;double&gt;(f);</br>
                                    to_double = (double)f; // Fonctionne aussi</br>
                                    int to_int = static_cast&lt;int&gt;(to_double);</br>
                                    f = 148; // Fonctionne grâce au constructeur de conversion
                                </div>
                                Dans le cas des types primaires numériques, la conversion est une simple perte de précision des valeurs (par exemple, de 32 à 16 bits, ou de décimal à entier).
                            </p>
                            <p id="part_A_b_4">
                                La conversion via "static_cast" est la plus sécurisée et la plus sûre, car <u>elle s'appuie sur quelque chose de définit par l'utilisateur</u>.
                                Cependant, dans certains cas, d'autre types de conversions s'avèrent nécessaire.
                                <span class="important">L'autre type de conversion assez utilisée est la conversion via "reinterpret_cast&lt;nouveau_type&gt;(valeur)"</span>.
                                La conversion de la valeur est effectué vers le type demandé, mais <u>la valeur n'est absolument pas modifiée dans la mémoire (la façon dont les bits sont agencés dans la mémoire n'est pas modifiée)</u>.
                                <u>Si la valeur à convertir n'est pas utilisable avec le nouveau type (même taille, même erreurs possibles...), vous pouvez avoir des erreurs de mémoire (particulièrement aganceant à détecter)</u>.
                                Un exemple d'utilisation est la conversion d'une valeur quelconque en valeur numérique, pour pouvoir y effectuer des opérations binaires.
                                Voici une implémentation de cette exemple :
                                <div class="code_sample">
                                    double to_double = 0.4523;</br>
                                    long long to_long_long = reinterpret_cast&lt;long long&gt;(to_double); // Même taille de variable (64 bits)</br>
                                    char deconseille = reinterpret_cast&lt;char&gt;(to_double); // Pas la lême taille de variable (8 bits et 64 bits)
                                </div>
                                Elle peut aussi être utilisée pour réinterpréter des pointeurs facilement (avec les mêmes risques mentionnés avant).
                                Donc, à utiliser avec modération.
                            </p>
                            <p id="part_A_b_5">
                                Pour finir, vous avez aussi des types de conversions moins utilisés.
                                <span class="important">Un autre opérateur qui peut être utile dans certains cas est "dynamic_cast&lt;nouveau_type*&gt;(pointeur*)"</span>.
                                <u>Il s'agit d'un convertisseur de pointeur vers une classe en convertisseur de pointeur vers une autre classe</u>.
                                Il ne modifie pas l'adresse du pointeur, mais juste la façon dont le type à cette variable doit être interprété.
                                Il ressemble beaucoup à "reinterpret_cast", <u>avec comme seule différence qu'il ne prend que des pointeurs, et qu'il effectue une vérification de la possibilité d'effectuer la conversion (au moment de la conversion)</u>.
                                Cela prend un peu de temps, mais est nécessaire dans certains cas (par exemple, pour gérer du polymorphisme, ou un type parent représente tous les enfants, et que nous devons le convertir en un type enfant pour X ou Y raison).
                                <span class="important">C'est tout l'inverse du certain opérateur, qui est (à mon avis) totalement inutile: "const_cast&lt;nouveau_type*&gt;(pointeur_constant)"</span>.
                                <u>Il permet de rendre un type étant définit "constant" comme un type normal, et vice versa</u>.
                                Il est (à mon avis) inutile car le premier cas n'est pas sencé avoir lieu (le type est constant pour une raison), et le 2 peut être fait de manière implicite par le compiler.
                                Il peut quand même être utilisé dans certains cas extrêmement (vraiment) particulier.
                            </p>
                        </div>
                        <h3 id="part_A_c">
                            c. Optimiser le fonctionnement des types
                        </h3>
                        <div>
                            <p id="part_A_c_1">
                                <u>La création / utilisation de type peut être un processus assez complexe, qui demande pas mal de réflection</u>.
                                Il est donc important de bien réflechier à ce que l'on va faire, pour ne pas casser le code (et l'ordinateur avec).
                            </p>
                            <p id="part_A_c_2">
                                <span class="important">Une chose assez important est de prioriser l'utilisation de pointeur dans les classes à l'utilisation d'objet bruts</span>.
                                En effet, une classe peut très vite devenir très lourde dans la mémoire, et poser des problèmes de mémoire.
                                <u>C'est ici que les pointeurs partagés seront utiles, pour éviter de tout casser bêtement</u>.
                                Donc, n'ayez pas peur de les utiliser quand c'est nécessaire.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_B">
                        B. Utiliser leur plein potentiel
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Cette partie est axée plutot sur l'utilisation des types hors des classes.
                        <h3 id="part_B_a">
                            a. Le "type" fonction
                        </h3>
                        <div>
                        </div>
                        <h3 id="part_B_b">
                            b. Les types standards
                        </h3>
                        <div>
                        </div>
                        <h3 id="part_B_c">
                            c. Les documentations de types
                        </h3>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/aster-school" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>