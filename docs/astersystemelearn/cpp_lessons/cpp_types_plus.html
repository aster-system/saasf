<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - C++ II-5</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <img alt="Logo de SAASF" src="../../images/logo.png"/>
            <nav>
                <div>
                    <a>
                        Lycée
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
                <div>
                    <a>
                        Aster Système Learn
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
            </nav>
        </header>
        <div id="main_div">
            <h1>
                II - 5. Manier les types dans leur intégralité
            </h1>
            <div>
                Nous n'en avons pas fini des types et de leur maniement.
                En effet, il y a encore des choses plus secondaires à dire, bien que très pratique dans beaucoup de cas.
                Nous allons en finir avec eux dans ce cours, via tous les paradigmes que nous avons vu jusque ici.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Étendre leur utilisation
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Cette partie est axée réalisation de types via les classes, bien qu'elle pérsente aussi bien une partie de leur utilisation hors des classes.
                        <h3 id="part_A_a">
                            a. Les opérateurs de classes
                        </h3>
                        <div>
                            <p id="part_A_a_1">
                                Nous avons déjà parlé des opérateurs il y a bien longtemps, avec le cours <a href="./cpp_variables.html">sur les variables</a>.
                                Par exemple, nous pouvons écrire "int a = 5 + 8;".
                                En effet, <u>le C++ convertit cela en code assembleur permettant une addition de deux nombres</u>.
                                Cependant, nous pouvons aussi faire "std::string a = "Hello"; std::string b = " world !";".
                                La question ici est comment le C++ utiliser l'opérateur "+" avec des valeurs qui ne sont pas des nombres ?
                                La réponse est simple : <span class="important">nous pouvons définir dans une classe la façon dont une instance va réagir avec un opérateur</span>.
                                C'est grâce à ça que des sommes de string donne des strings plus long.
                            </p>
                            <p id="part_A_a_2">
                                En fait, <span class="important">ces opérateurs appellent des fonctions spéciales dans les classes, que nous pouvons donc réecrire via le principe d'héritage (voir <a href="./cpp_class.html">le cours sur les classes</a>)</span>.
                                <u>Cette opération est nommée la surchage d'opérateurs</u>.
                                Dans le cas des opérateurs simples "+", "-", "*" et "/", la fonction en question est très simple :
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur +</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex operator+(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real() + other_complex.real(), imaginary() + other_complex.imaginary());</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur -</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex operator-(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real() - other_complex.real(), imaginary() - other_complex.imaginary());</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Cette syntaxe marche aussi avec les opérateurs "*" et "/", mais je vous épargne leur implémentation avec des nombres complexes.
                                Ici, les fonctions effectuent les opérations sur une nouvelle instance de complexe, et retourne la résultat (qui sera interprété comme le résutlat de l'opérateur).
                                La fonction n'a pas besoin d'être modifié ici, elle peut être notée constante.
                                Vous pouvez maintenant faire des opérations simples avec les classes.
                            </p>
                            <p id="part_A_a_3">
                                Vous pouvez aussi magnier d'autres opérateurs, <span class="important">comme les opérateurs d'assignement</span>.
                                <u>Il peut s'agir de n'importe quel opérateur contenant un "=", comme "+=" ou "/="</u>:
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur +=</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;void operator+=(Complex other_complex) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_real += other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_imaginary += other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur -=</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;void operator-=(Complex other_complex) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_real -= other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_imaginary -= other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, ils modifient l'instance, et donc ne sont pas constants.
                                De plus, il n'ont (en général) pas besoin de retourner quoi que ce soit, donc ils ne retournent rien.
                                Cependant, si pour une quelconque raison, un retour est demandé, <u>alors il s'agit presque toujours d'une référence vers l'instance de la classe qui subit l'opération</u>.
                                Pour cela, <span class="important">il vous faut un moyen d'accéder à la classe directement via elle même, en utilisant le mot clé "this", qui renvoit un pointeur vers l'instance elle même</span>.
                                Pour le spécifier en référence, il faut donc rajouter "*" dedans (voir <a href="./cpp_pointers.html">le cours sur les pointeurs</a>), et retourner "return *this;".
                                <u>Ce mot clé peut être utilisé dés que vous avez besoin d'un pointeur ou d'une référence vers l'instance, directement dans l'instance elle même</u>.
                            </p>
                            <p id="part_A_a_4">
                                <span class="important">Les derniers types d'opérateurs surchageables très utilisés sont les opérateurs de comparaisons</span>.
                                Leur fonctionnement reste très similaire:
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ==</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator==(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() == other_complex.real() && imaginary() == other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator>(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() > other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, ils ne modifient pas l'instance, et donc peuvent être constants.
                                Ils retournent le résultat de l'opération, sous forme de booléen, de manièr extrêmement similaire aux opérateurs vus plus haut.
                                Il est cependant à noter que dire qu'un nombre complexe est plus grand qu'un nombre est superflu, mais par soucis de simplicité, on va dire que, ici, un nombre complexe est plus grand si sa partie réelle est plus grande (s'il vous plait les professeurs de maths, ne me tapez pas).
                            </p>
                            <p id="part_A_a_5">
                                Une fois que vous compris le fonctionnement de ces fonctions, <span class="important">vous pouvez créer l'opérateur que vous voulez, selon le même principe</span>.
                                Voici quelques exemples d'opérateurs (très aléatoire et peu adaptés à une classe complexe, mais là pour l'exemple):
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur []</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double operator[](unsigned int index) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(index == 0) return real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ()</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator->(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() > other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, l'opérateur "()" est un opérateur utilisable sur une instance (pas une fonction, mais une instance), pour lui faire faire ce que l'on veut.
                                C'est d'ailleurs l'opérateur utilisé pour la génération de nombres aléatoires, vu dans le cours <a href="./cpp_algorithm_data_structure.html">sur les algorithmes</a>.
                                Les possibilités sont infinies.
                            </p>
                            <p id="part_A_a_6">
                                <span class="important">Une dernière façon de faire est la définition de fonction d'opérateurs hors d'une classe</span>.
                                Ce cas est utile par exemple pour pouvoir utiliser une classe avec "std::cout" et l'opérateur "&lt;&lt;", ou pour utiliser un "int" avant un opérateur quelconque.
                                En effet, <u>chaque fonction d'opérateur peut en fait être surcharger hors de la classe (c'est moins intuitif, mais nécessaires dans certains cas)</u>.
                                <u>La valeur / type du premier opérande est donc spécifié en 1er paramètre de la fonction, et la valeur / type du second opérande est le deuxième paramètre (l'ordre à un sens très important ici)</u>:
                                <div class="code_sample">
                                std::ostream& operator&lt;&lt;(std::ostream& os, Complex c) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet de "std::cout" un "Complex"</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return os &lt;&lt; c.real() &lt;&lt; " + " &lt;&lt; c.imaginary() &lt;&lt; " * i";</br>
                                }</br></br>
                                Complex operator+(int n, Complex c) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet d'additioner un "int" avec un "Complex"</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return Complex(c.real() + n, c.imaginary());</br>
                                }</br>
                                Complex operator+(Complex c, int n) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet d'additioner un "Complex" avec un "int" (exactement pareil à la fonction définie dans la classe)</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return Complex(c.real() + n, c.imaginary());</br>
                                }
                                </div>
                                D'ailleurs, il faut savoir que "std::cout" est l'instance (globale) d'une classe <a href="https://en.cppreference.com/w/cpp/io/basic_ostream" target="_blank">"std::ostream"</a>, ici utilisable via la référence "os" (que l'on doit d'ailleurs retourner juste après).
                                Faite bien attention à l'ordre, et rendez vous la vie plus facile avec ces systèmes.
                            </p>
                        </div>
                        <h3 id="part_A_b">
                            b. Les conversions de types
                        </h3>
                        <div>
                            <p id="part_A_b_1">
                                Pour rappel, <u>il existe une aberrante quantité de façon de typer un nombre : int, double, long</u>...
                                Cependant, <u>il n'y a pas de problème à convertir un int en double, (ou un double en int), avec une simple assignation</u>.
                                Nous avons pourtant vu dans le <a href="./cpp_variables.html">cours sur les variables</a> que les doubles ne sont pas représentés en binaire de la même façon que les int, un changement de forme doit donc être fait.
                                <span class="important">L'opération de transformer une donnée d'une certaine forme en une donnée d'une autre forme (mais d'inteprération similaire), et donc d'un autre type est nommée la conversion de type</span>.
                                Dans le cas des nombres, <u>cette opération est effectuée automatiquement par le compiler (c'est ce que l'on appelle une conversion implicite)</u>.
                                De plus, il y a plusieurs moyens de faire cette conversion, que allons voir tout de suite.
                            </p>
                            <p id="part_A_b_2">
                                <span class="important">Les autres types de conversions sont appellées conversions explicites</span>.
                                La façon la plus simple de convertir explicitement un type est d'utiliser des parenthèses avec le type nécessaire, avant la valeur à convertir:
                                <div class="code_sample">
                                    int entier = 6;</br>
                                    double decimal = (double)entier;
                                </div>
                                Ici, on prend la valeur de "entier", on obtient sa valeur en double, et on l'assigne dans "decimal".
                                Cependant, <u>la façon dont fonctionne cette conversion dépend du type, car il y a en effet plusieurs types de conversion possibles</u> (le compiler choisit la plus adaptée lors de la compilation).
                            </p>
                            <p id="part_A_b_3">
                                Cette méthode reste imprécise, puis ce qu'elle nous permet pas de spécifier très précisément le type de conversion.
                                Pour effectuer une conversion de manière plus précise, <span class="important">il faut utiliser un opérateur de conversion</span>.
                                <span class="important">Le plus utilisé est l'opérateur "static_cast&lt;nouveau_type&gt;(variable_a_convertir)"</span>.
                                <u>Il demande au compiler d'aller chercher dans le type de la variable à convertir un moyen de conversion vers le type demandé</u>.
                                Pour cela, <u>il cherche une surchage de deux méthodes très précises : la méthode de l'opérateur "operator nouveau_type()" et les constructeurs des conversions</u>.
                                Ma méthode "operateur" retourne une instance du type final de la conversion, qui peut s'interpréter comme l'instance utilisée pour la conversion.
                                Le constructeur converti une valeur donnée d'un certain type, directement vers l'instance.
                                Voici un exemple d'utilisation de ces méthodes :
                                <div class="code_sample">
                                    class Fraction {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant une fraction</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Fraction(double numerator, double denominator) : a_denominator(denominator), a_numerator(numerator) {};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de conversion (long long vers Fraction)</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Fraction(long long numerator) : Fraction(numerator, 1) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline long long denominator() const {return a_denominator;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline long long numerator() const {return a_numerator;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur de conversion vers "double"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;operator double() const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return numerator() / denominator();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Dénominateur de la fraction</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;long long a_denominator = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Numérateur de la fraction</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;long long a_numerator = 0;</br>
                                    };
                                </div>
                                Donc, une bonne utilisation de "static_cast" pour tout cela serai :
                                <div class="code_sample">
                                    Fraction f(54, 65);</br>
                                    double to_double = static_cast&lt;double&gt;(f);</br>
                                    to_double = (double)f; // Fonctionne aussi</br>
                                    int to_int = static_cast&lt;int&gt;(to_double);</br>
                                    f = 148; // Fonctionne grâce au constructeur de conversion
                                </div>
                                Dans le cas des types primaires numériques, la conversion est une simple perte de précision des valeurs (par exemple, de 32 à 16 bits, ou de décimal à entier).
                            </p>
                            <p id="part_A_b_4">
                                La conversion via "static_cast" est la plus sécurisée et la plus sûre, car <u>elle s'appuie sur quelque chose de définit par l'utilisateur</u>.
                                Cependant, dans certains cas, d'autre types de conversions s'avèrent nécessaire.
                                <span class="important">L'autre type de conversion assez utilisée est la conversion via "reinterpret_cast&lt;nouveau_type&gt;(valeur)"</span>.
                                La conversion de la valeur est effectué vers le type demandé, mais <u>la valeur n'est absolument pas modifiée dans la mémoire (la façon dont les bits sont agencés dans la mémoire n'est pas modifiée)</u>.
                                <u>Si la valeur à convertir n'est pas utilisable avec le nouveau type (même taille, même erreurs possibles...), vous pouvez avoir des erreurs de compiler (forçant à passer par des pointeurs, comme dans l'exemple ci-dessous) ou de mémoire (particulièrement aganceant à détecter)</u>.
                                Un exemple d'utilisation est la conversion d'une valeur quelconque en valeur numérique via un pointeur, pour pouvoir y effectuer des opérations binaires.
                                Voici une implémentation de cette exemple :
                                <div class="code_sample">
                                    double to_double = 0.4523;</br>
                                    long long to_long_long = *reinterpret_cast&lt;long long*&gt;(to_double); // Même taille de variable (64 bits)</br>
                                    char deconseille = *reinterpret_cast&lt;char*&gt;(to_double); // Pas la lême taille de variable (8 bits et 64 bits)
                                </div>
                                Elle est utilisée ici pour réinterpréter un pointeur facilement (avec les mêmes risques mentionnés avant), pour lire le "double" en "long long".
                                Donc, à utiliser avec modération.
                            </p>
                            <p id="part_A_b_5">
                                Pour finir, vous avez aussi des types de conversions moins utilisés.
                                <span class="important">Un autre opérateur qui peut être utile dans certains cas est "dynamic_cast&lt;nouveau_type*&gt;(pointeur*)"</span>.
                                <u>Il s'agit d'un convertisseur de pointeur vers une classe en convertisseur de pointeur vers une autre classe</u>.
                                Il ne modifie pas l'adresse du pointeur, mais juste la façon dont le type à cette variable doit être interprété.
                                Il ressemble beaucoup à "reinterpret_cast", <u>avec comme seule différence qu'il ne prend que des pointeurs, et qu'il effectue une vérification de la possibilité d'effectuer la conversion (au moment de la conversion)</u>.
                                Cela prend un peu de temps, mais est nécessaire dans certains cas (par exemple, pour gérer du polymorphisme, ou un type parent représente tous les enfants, et que nous devons le convertir en un type enfant pour X ou Y raison).
                                <span class="important">C'est tout l'inverse du certain opérateur, qui est (à mon avis) totalement inutile: "const_cast&lt;nouveau_type*&gt;(pointeur_constant)"</span>.
                                <u>Il permet de rendre un type étant définit "constant" comme un type normal, et vice versa</u>.
                                Il est (à mon avis) inutile car le premier cas n'est pas sencé avoir lieu (le type est constant pour une raison), et le 2 peut être fait de manière implicite par le compiler.
                                Il peut quand même être utilisé dans certains cas extrêmement (vraiment) particulier.
                            </p>
                        </div>
                        <h3 id="part_A_c">
                            c. Optimiser le fonctionnement des types
                        </h3>
                        <div>
                            <p id="part_A_c_1">
                                <u>La création / utilisation de type peut être un processus assez complexe, qui demande pas mal de réflection</u>.
                                Il est donc important de bien réflechier à ce que l'on va faire, pour ne pas casser le code (et l'ordinateur avec).
                            </p>
                            <p id="part_A_c_2">
                                <span class="important">Une chose assez important est de prioriser l'utilisation de pointeur dans les classes à l'utilisation d'objet bruts</span>.
                                En effet, une classe peut très vite devenir très lourde dans la mémoire, et poser des problèmes de mémoire.
                                <u>C'est ici que les pointeurs partagés seront utiles, pour éviter de tout casser bêtement</u>.
                                Donc, n'ayez pas peur de les utiliser quand c'est nécessaire.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_B">
                        B. Utiliser leur plein potentiel
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Cette partie est axée plutot sur l'utilisation des types hors des classes.
                        <h3 id="part_B_a">
                            a. Le "type" fonction
                        </h3>
                        <div>
                            <p id="part_B_a_1">
                                Jusqu'à maintenant, nous nous sommes efforcés de bien différencier les variables des fonctions.
                                Cependant, dans cette partie, <u>nous allons établir un lien définitif entre ces 2 concepts</u>.
                                En effet, <span class="important">une fonction peut être utilisée via un pointeur ou une référence</span>.
                                La variable pointeur / référence (contenant l'adresse vers la fonction) se comporte comme n'importe quel pointeur / référence.
                            </p>
                            <p id="part_B_a_2">
                                Pour créer un pointeur ou une référence vers une fonction, la syntaxe est assez complexe.
                                <span class="important">Elle demande le type de retour et les types d'arguments, sous la forme : "type_de_retour (*nom_du_pointeur)(type_d_argument...)"</span>.
                                Voici un exemple d'utilisation :
                                <div class="code_sample">
                                    // Création d'une fonction cobaye</br>
                                    int function(int value) {return value * 10 - 4;};</br></br>
                                    // Création d'un pointeur vers des fonctions retournant "int" prenant 1 argument "int"</br>
                                    int (*pointeur)(int) = &function; // Pointe vers "function"</br>
                                    int (&pointeur)(int) = function; // Référence vers "function"
                                </div>
                                Les opérations classiques des fonctions (appel) peuvent être effectué directement via le pointeur (sans modifications nécessaires à apporter au pointeur) :
                                <div class="code_sample">
                                    // Appel de "function"</br>
                                    int valeur = pointeur(23);
                                </div>
                                L'écriture du type nécessaire pouvant s'avérer assez longue dans certains cas, <u>vous pouvez aussi utiliser typedef, et définir les pointeurs via ce typedef</u>:
                                <div class="code_sample">
                                    // Création du type de pointeur nécessaire</br>
                                    typedef int (*Pointeur)(int)</br>
                                    typedef int (&Reference)(int)</br></br>
                                    // Création d'un pointeur vers des fonctions retournant "int" prenant 1 argument "int"</br>
                                    Pointeur pointeur = &function; // Pointe vers "function"</br>
                                    Reference reference = function; // Référence vers "function"
                                </div>
                            </p>
                            <p id="part_B_a_3">
                                <span class="important">L'avantage de ces types spéciaux est l'utilisation possible de fonction spécifiques, non via leur appel direct, mais via un pointeur</span>.
                                Cela peut être très intéressant pour certaines tâches nécessitant une utilisation très spécifique via une fonction, mais où la réimplémentation à chaque fois s'avère complexe.
                                Un exemple est une fonction définie dans l'include "algorithm" du C++ : <a href="https://en.cppreference.com/w/cpp/algorithm/sort">sort</a>, qui permet de trier un tableau.
                                En effet, pour vérifier si un objet est plus petit qu'un autre, <u>il peut faire appel à une fonction spéciale, passée en paramètre</u>.
                                Voici un exemple d'utilisation de cette fonction :
                                <div class="code_sample">
                                    // Création de la fonction de comparaisons</br>
                                    bool compare_string(const std::string& a, const std::string& b) {return a.size() &lt; b.size();}</br></br>
                                    // Création d'un vecteur quelconque de std::string</br>
                                    std::vector&lt;std::string&gt; texts = lot_of_texts();</br>
                                    std::sort(texts.begin(), texts.end(), compare_string); // Tri du tableau</br>
                                </div>
                                La seule condition est que la fonction est la forme demandée dans la documentation, donc "bool cmp(const Type1& a, const Type2& b)".
                                Grâce à ça, les possibilités deviennent infinies.
                            </p>
                        </div>
                        <h3 id="part_B_b">
                            b. Les types standards
                        </h3>
                        <div>
                            <p id="part_B_b_1">
                                Pour l'instant, vous pouvez créer et faire un peu ce que vous voulez avec vos propres types.
                                Cependant, <u>l'utilisation des types crées par d'autres personnes peut s'avérer plus compliqué</u>.
                                Dans le cas où vous seriez un sage gourou des montagnes, vous pouvez vous passer d'utiliser beaucoup de types qui ne sont pas fait par vous.
                                Cependant, <span class="important">il y a une catégorie de types auquelles vous ne pourrez pas échapper : les types standard</span>.
                                Nous en avons déjà beaucoup parlé, <u>puis ce qu'il s'agit des types que nous pouvons utiliser avec des "includes"</u>.
                                En effet, je vous les avez très légèrement introduit lors du cours sur <a bref="./cpp_organise.html">les projets C++</a>.
                                Ici, on va en reparler plus précisément.
                            </p>
                            <p id="part_B_b_2">
                                Les types standard que nous avons le plus utilisé sont <a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_blank">string</a>, <a href="https://en.cppreference.com/w/cpp/container/vector" target="_blank">vector</a> et <a href="https://en.cppreference.com/w/cpp/io/basic_iostream" target="_blank">iostream</a>.
                                Vous pouvez consulter leur documentation respective, en cliquant sur la classe que vous souhaitez découvrir.
                                Bien qu'il existe une myriade de documentations C++, <span class="important">celle que j'utilise pour les types standards est le site web <a href="https://en.cppreference.com/w/" target="_blank">C++ Reference</a>, un site web de forme wiki en anglais.</span>
                                Cependant, si vous n'êtes pas à l'aise en anglais, plein d'autres documentations existent, en plein de langues, comme <a href="https://learn.microsoft.com/fr-fr/cpp/cpp/cpp-language-reference?view=msvc-170" target="_blank">celle en français de Microsoft</a>.
                                Surtout, <span class="important">n'ayez pas peur de cliquer sur des trucs au hasard pour découvrir, et n'ayez pas peur de faire des recherches (directement sur le site web ou sur Google) si vous avez un problème</span>.
                                Théoriquement, Vous devriez être capable de tout capable avec le cours présent ici (accompagné de recherches Google si nécessaire).
                            </p>
                            <p id="part_B_b_2">
                                Pour vous aider, nous allons plonger dans la documentation d'un type bien précis, et très utile dans grand nombre de manipulation en C++ : <a rhef="https://en.cppreference.com/w/cpp/io/basic_ios">basic_ios et ses enfants</a>.
                                En effet, <span class="important">une des opérations primaires pour un ordinateur que nous n'avons pas réalisé pour l'instant est la modification de fichiers</span>.
                                Cette opération est une sorte de sortie de données vers un fichier, réalisée via la classe <a href="https://en.cppreference.com/w/cpp/io/basic_fstream" target="_blank">fstream</a>, enfant de "basic_ios".
                                Pour l'utiliser (comme dans toutes les classes), <u>la documentation met à disposition la façon de faire, ainsi que les méthodes nécessaires</u>.
                                Selon CPP Reference, on apprend que cette classe sert à manipuler un fichier, avec le système de "stream".
                                En lisant un peu plus, on apprend que cette classe est fille de <a href="https://en.cppreference.com/w/cpp/io/basic_istream" target="_blank">ifstream</a>, qui permet de faire rentrer des données dans le "stream", et <a href="https://en.cppreference.com/w/cpp/io/basic_ostream" target="_blank">ostream</a>, qui permet de faire sortir des données venant du "stream".
                                En gros, <u>l'entrée représente l'écriture dans un fichier, et la sortie représente la lecture d'un fichier</u>, <span class="important">donc cette classe permet de lire et écrire dans un fichier</span>.
                                En lisant les documentations de ces deux classes, <u>vous pouvez donc réaliser précisément des opérations sur des fichiers</u>.
                                <span class="important">Un petit défi pour vous serait de vous demander de réaliser un petit programme pour écrire ce que bon vous semble dans un fichier, juste avec la documentation</span>.
                                Tout ça pour dire que la documentation est extrêmement importante à étudier pour écrire votre code, tout en contenant des données que vous ne pourriez ne pas avoir remarqué sans (comme, par exemple, l'origine de <a href="https://en.cppreference.com/w/cpp/io/cout" target="_blank">cout</a> et ses liens avec istream).
                                D'ailleurs, l'opérateur de "stream" "operator&lt;&lt;" et la syntaxe nécessaire pour l'écrire que nous avons créer tout à l'heure est présent dans la documentation de <a href="https://en.cppreference.com/w/cpp/io/basic_ostream" target="_blank">ostream</a> (je vous laisse chercher où, et <a href="https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2" target="_blank">voici la réponse pour ce que ne trouverait pas</a>).
                                Faites attention, il est présent à deux endroit différents, dans la partie membre (définie dans la classe) et dans la partie non-membre (définie hors de la classe, comme nous avons fait), il faut donc choisir la bonne (et donc bien lire ce qui est écrit dans la documentation).
                            </p>
                        </div>
                        <h3 id="part_B_c">
                            c. Les documentations de types
                        </h3>
                        <div>
                            <p id="part_B_c_1">
                                <u>La logique de l'univers voudrait que toute librairie, quel qu'elle soit, est un site web avec sa documentation dessus</u>.
                                En général, <span class="important">c'est le cas, et le lien vers la documentation est quelque part sur le site web de la librairie</span>.
                                Les librairies dans ce cas sont nombreuses, comme <a href="https://www.glfw.org/" target="_blank">GLFW</a> pour les interfaces graphiques ou <a href="https://www.portaudio.com/" target="_blank">PortAudio</a> pour la gestion de l'audio.
                                C'est la façon la plus simple d'utiliser une librairie.
                            </p>
                            <p id="part_B_c_2">
                                <u>Malheuresement, certains aiment se casser la tête, et n'écrivent pas leur documentation de cette façon</u>.
                                Dans ce cas là, <span class="important">la documentation est soit embarquée dans un fichier .pdf, soit dans un fichier .html, soit directement dans les headers</span>.
                                Le meilleur exemple de librairie dans ce cas là est la très célèbre librairie de compression de données <a href="https://zlib.net/" target="_blank">ZLib</a>.
                                Si la documentation est dans les headers, <u>il faut donc aller regarder et étudier chaque fonction / classe / struct, pour apprendre leur fonctionnement</u>.
                                De plus, n'hésitez pas à regarder des morceaux de code et des exemples, pour apprendre plus vite.
                            </p>
                            <p id="part_B_c_3">
                                Une dernière chose que nous allons voir peut paraître évidente pour certain, mais ne l'est pas comme on peut l'imaginer.
                                En effet, si vous télécharger une librarie sur un quelconque sujet, <span class="important">son utilisation demande des connaissances sur ce même sujet</span>.
                                Par exemple, lancer une musique via une librairie audio via une seule ligne de code et rien d'autre ne veut pas dire grand chose dans un logiciel contenant une boucle générale d'exécution.
                                Or, <u>actualiser le son à chaque itération de la boucle pour écouter la musique petit à petit est beaucoup plus réaliste</u>.
                                Cependant, pour cela, il faut comprendre la façon dont la librairie gère le son.
                                Beaucoup de choses pour dire qu'avant d'utiliser une librairie, <span class="important">apprenez à la connaître et à l'utiliser, pour éviter les mauvaises surprises dans le futur</span>.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/aster-school" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>