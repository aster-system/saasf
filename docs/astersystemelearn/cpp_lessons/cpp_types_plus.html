<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - Hub</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <img alt="Logo de SAASF" src="../../images/logo.png"/>
            <nav>
                <div>
                    <a>
                        Lycée
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
                <div>
                    <a>
                        Aster Système Learn
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
            </nav>
        </header>
        <div id="main_div">
            <h1>
                II - 5. Manier les type dans leur intégralité
            </h1>
            <div>
                Nous n'en avons pas fini des types et de leur maniement.
                En effet, il y a encore des choses plus secondaires à dire, bien que très pratique dans beaucoup de cas.
                Nous allons en finir avec eux dans ce cours, via tous les paradigmes que nous avons vu jusque ici.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Étendre leur utilisation
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Cette partie est axée réalisation de types via les classes, bien qu'elle pérsente aussi bien une partie de leur utilisation hors des classes.
                        <h3 id="part_A_a">
                            a. Les opérateurs de classes
                        </h3>
                        <div>
                            <p id="part_A_a_1">
                                Nous avons déjà parlé des opérateurs il y a bien longtemps, avec le cours <a href="./cpp_variables.html">sur les variables</a>.
                                Par exemple, nous pouvons écrire "int a = 5 + 8;".
                                En effet, <u>le C++ convertit cela en code assembleur permettant une addition de deux nombres</u>.
                                Cependant, nous pouvons aussi faire "std::string a = "Hello"; std::string b = " world !";".
                                La question ici est comment le C++ utiliser l'opérateur "+" avec des valeurs qui ne sont pas des nombres ?
                                La réponse est simple : <span class="important">nous pouvons définir dans une classe la façon dont une instance va réagir avec un opérateur</span>.
                                C'est grâce à ça que des sommes de string donne des strings plus long.
                            </p>
                            <p id="part_A_a_2">
                                En fait, <span class="important">ces opérateurs appellent des fonctions spéciales dans les classes, que nous pouvons donc réecrire via le principe d'héritage (voir <a href="./cpp_class.html">le cours sur les classes</a>)</span>.
                                <u>Cette opération est nommée la surchage d'opérateurs</u>.
                                Dans le cas des opérateurs simples "+", "-", "*" et "/", la fonction en question est très simple :
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur +</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex operator+(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real() + other_complex.real(), imaginary() + other_complex.imaginary());</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur -</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex operator-(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Complex(real() - other_complex.real(), imaginary() - other_complex.imaginary());</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Cette syntaxe marche aussi avec les opérateurs "*" et "/", mais je vous épargne leur implémentation avec des nombres complexes.
                                Ici, les fonctions effectuent les opérations sur une nouvelle instance de complexe, et retourne la résultat (qui sera interprété comme le résutlat de l'opérateur).
                                La fonction n'a pas besoin d'être modifié ici, elle peut être notée constante.
                                Vous pouvez maintenant faire des opérations simples avec les classes.
                            </p>
                            <p id="part_A_a_3">
                                Vous pouvez aussi magnier d'autres opérateurs, <span class="important">comme les opérateurs d'assignement</span>.
                                <u>Il peut s'agir de n'importe quel opérateur contenant un "=", comme "+=" ou "/="</u>:
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur +=</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;void operator+=(Complex other_complex) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_real += other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_imaginary += other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur -=</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;void operator-=(Complex other_complex) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_real -= other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a_imaginary -= other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, ils modifient l'instance, et donc ne sont pas constants.
                                De plus, il n'ont (en général) pas besoin de retourner quoi que ce soit, donc ils ne retournent rien.
                            </p>
                            <p id="part_A_a_4">
                                <span class="important">Les derniers types d'opérateurs surchageables très utilisés sont les opérateurs de comparaisons</span>.
                                Leur fonctionnement reste très similaire:
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ==</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator==(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() == other_complex.real() && imaginary() == other_complex.imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator>(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() > other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, ils ne modifient pas l'instance, et donc peuvent être constants.
                                Ils retournent le résultat de l'opération, sous forme de booléen, de manièr extrêmement similaire aux opérateurs vus plus haut.
                                Il est cependant à noter que dire qu'un nombre complexe est plus grand qu'un nombre est superflu, mais par soucis de simplicité, on va dire que, ici, un nombre complexe est plus grand si sa partie réelle est plus grande (s'il vous plait les professeurs de maths, ne me tapez pas).
                            </p>
                            <p id="part_A_a_5">
                                Une fois que vous compris le fonctionnement de ces fonctions, <span class="important">vous pouvez créer l'opérateur que vous voulez, selon le même principe</span>.
                                Voici quelques exemples d'opérateurs (très aléatoire et peu adaptés à une classe complexe, mais là pour l'exemple):
                                <div class="code_sample">
                                    class Complex {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Classe décrivant un nombre complex "R + iIm"</br></br>
                                    public:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Constructeur de la classe "Complex"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;Complex(double real, double imaginary) : a_imaginary(imaginary), a_real(real) {};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Getters et setters</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double imaginary() const {return a_imaginary;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;inline double real() const {return a_real;};</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur []</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double operator[](unsigned int index) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(index == 0) return real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return imaginary();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Surchage de l'opérateur ()</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;bool operator->(Complex other_complex) const {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return real() > other_complex.real();</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;};</br></br>
                                    private:</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur imaginaire du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_imaginary = 0;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// Valeur réelle du complexe</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;double a_real = 0;</br>
                                    };
                                </div>
                                Ici, l'opérateur "()" est un opérateur utilisable sur une instance (pas une fonction, mais une instance), pour lui faire faire ce que l'on veut.
                                C'est d'ailleurs l'opérateur utilisé pour la génération de nombres aléatoires, vu dans le cours <a href="./cpp_algorithm_data_structure.html">sur les algorithmes</a>.
                                Les possibilités sont infinies.
                            </p>
                            <p id="part_A_a_6">
                                <span class="important">Une dernière façon de faire est la définition de fonction d'opérateurs hors d'une classe</span>.
                                Ce cas est utile par exemple pour pouvoir utiliser une classe avec "std::cout" et l'opérateur "&lt;&lt;", ou pour utiliser un "int" avant un opérateur quelconque.
                                En effet, <u>chaque fonction d'opérateur peut en fait être surcharger hors de la classe (c'est moins intuitif, mais nécessaires dans certains cas)</u>.
                                <u>La valeur / type du premier opérande est donc spécifié en 1er paramètre de la fonction, et la valeur / type du second opérande est le deuxième paramètre (l'ordre à un sens très important ici)</u>:
                                <div class="code_sample">
                                std::ostream& operator&lt;&lt;(std::ostream& os, Complex c) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet de "std::cout" un "Complex"</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return os &lt;&lt; c.real() &lt;&lt; " + " &lt;&lt; c.imaginary() &lt;&lt; " * i";</br>
                                }</br></br>
                                Complex operator+(int n, Complex c) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet d'additioner un "int" avec un "Complex"</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return Complex(c.real() + n, c.imaginary());</br>
                                }</br>
                                Complex operator+(Complex c, int n) {</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;// Permet d'additioner un "Complex" avec un "int" (exactement pareil à la fonction définie dans la classe)</br>
                                &nbsp;&nbsp;&nbsp;&nbsp;return Complex(c.real() + n, c.imaginary());</br>
                                }
                                </div>
                                D'ailleurs, il faut savoir que "std::cout" est l'instance (globale) d'une classe <a href="https://en.cppreference.com/w/cpp/io/basic_ostream" target="_blank">"std::ostream"</a>, ici utilisable via la référence "os" (que l'on doit d'ailleurs retourner juste après).
                                Faite bien attention à l'ordre, et rendez vous la vie plus facile avec ces systèmes.
                            </p>
                        </div>
                        <h3 id="part_A_b">
                            b. Les conversions de types
                        </h3>
                        <div>
                        </div>
                        <h3 id="part_A_c">
                            c. Optimiser le fonctionnement des types
                        </h3>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_B">
                        B. Utiliser leur plein potentiel
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Cette partie est axée plutot sur l'utilisation des types hors des classes.
                        <h3 id="part_B_a">
                            a. Le "type" fonction
                        </h3>
                        <div>
                        </div>
                        <h3 id="part_B_b">
                            b. Les types standards
                        </h3>
                        <div>
                        </div>
                        <h3 id="part_B_c">
                            c. Les documentations de types
                        </h3>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/aster-school" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>