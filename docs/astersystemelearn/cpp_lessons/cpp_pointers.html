<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - Lecon C++ - Pointeurs</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <img alt="Logo de SAASF" src="../../images/logo.png"/>
            <nav>
                <div>
                    <a>
                        Lycée
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
                <div>
                    <a>
                        Aster Système Learn
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
            </nav>
        </header>
        <div id="main_div">
            <h1>
                II - 3. Les pointeurs en C++
            </h1>
            <div>
                Parmis tous les types fondamentaux en C++, il ne nous en reste plus qu'un à étudier en profondeur : les pointeurs.
                Ce type est un cauchemar pour les étudiants en informatique, car il est l'un des plus difficile à utiliser dans sa totalité.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Le type "pointeur" en C++
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <h3 id="part_A_a">
                            a. Qu'est ce qu'est un pointeur ?
                        </h3>
                        <div>
                            <p id="part_A_a_1">
                                Pour comprendre les pointeurs, <u>nous allons avant déchiqueter un autre type que nous avons déjà vu : la référence</u>.
                                <span class="important">Une référence est un moyen d'accéder à une variable en copiant son adresse mémoire et en y accédant directement via elle</span>.
                                Pour rappel, nous en avons parler lors du cours sur les variables, <a href="cpp_variables.html">juste ici</a>.
                                Toutes modification à la référence seront appliquées à la variable référencée (d'où le nom) via l'adresse mémoire.
                                <u>Il n'y aucun moyen de modifier ou d'utiliser l'adresse mémoire en elle même (sans toucher à la variable référencée), la rendant particulièrement stable, mais aussi assez limité</u>.
                                Donc, <u>la variable référencée doit l'être à la création de la référence, et ne sera pas modifiable après</u>.
                                Par exemple, une utilité des références et de référencer en tant qu'attribut de classe une variable global hors de la classe, et de l'utiliser quand même via la référence.
                                Dans ce cas, comme nous l'avons déjà vu, la référence doit être passée via le constructeur et initialisée dans la classe avec la technique  :
                                <div class="code_sample">
                                    Constructeur(type variable_reference): reference(variable_reference) {}
                                </div>
                            </p>
                            <p id="part_A_a_2">
                                <u>La référence est, en fait, un type précis de pointeur</u>.
                                <span class="important">En effet, un pointeur est un moyen d'accéder à une variable en copiant son adresse mémoire et en y accédant directement via elle</span>.
                                Si vous êtes attentif, vous observerez que cette définition est exactement la même que celle de la référence.
                                En effet, <span class="important">la seule différence entre le pointeur et la référence est que, avec le pointeur, on peut agir sur l'adresse mémoire en elle même (sans toucher à la variable référencée)</span>.
                                En fait, <u>le pointeur représente plus une manipulation de l'adresse mémoire, qu'une manipulation de la variable pointée (on va utiliser ce terme ici, plutôt que référencée), bien que les deux soit possibles</u>.
                                Une variable "pointeur" peut pointer vers une autre variable n'importe quel type, selon sa déclaration, qui se fait avec un "*", comme ça :
                                <div class="code_sample">
                                    int age = 50;</br>
                                    int* pointeur_vers_age = &age;</br>
                                    int *pointeur_vers_age = &age; // La position du "*" n'importe pas ici
                                </div>
                                Cependant, avec les références, le compiler pouvait aller chercher l'adresse lui même.
                                Là, il faut lui attribuer l'adresse de la variable vous même.
                                <u>Pour accéder à l'adresse d'une variable, il faut rajouter un "&" devant</u>.
                                Vous pouvez connaître cette adresse grâce à "std::cout" (la valeur sera affiché en héxadécimal) :
                                <div class="code_sample">
                                    int age = 50;</br>
                                    int* pointeur_vers_age = &age;</br>
                                    std::cout &lt;&lt; "Adresse de la variable : " &lt;&lt; pointeur_vers_age &lt;&lt; std::endl;
                                </div>
                                Il est à noter qu'un pointeur, quel qu'il soit, occupe 8 octets dans la mémoire.
                            </p>
                            <p id="part_A_a_3">
                                <u>Si vous utilisez le pointeur directement, vous ne ferez rien sur la variable</u>.
                                <span class="important">Pour accéder à une simple référence vers la variable (et l'utiliser très simplement), vous devez rajouter "*" devant le nom du pointeur, comme ça </span>:
                                <div class="code_sample">
                                    int age = 50;</br>
                                    int* pointeur_vers_age = &age;</br>
                                    std::cout &lt;&lt; "Adresse de la variable : " &lt;&lt; pointeur_vers_age &lt;&lt; ", valeur dans la variable : " &lt;&lt; *pointeur_vers_age &lt;&lt; std::endl;</br></br>
                                    *pointeur_vers_age = 75;</br>
                                    std::cout &lt;&lt; "Nouvelle valeur de la variable : " &lt;&lt; *pointeur_vers_age &lt;&lt; std::endl;
                                </div>
                                Si vous pointez vers une instance de classe (comme la classe "Developer" vu <a href="cpp_class.html">au dernier cours</a>), <u>vous pouvez accéder aux méthodes via le pointeur avec l'aide d'un opérateur : "->" (vous avez juste à remplacer l'opérateur "." par celui ci) :</u>
                                <div class="code_sample">
                                    Developer dev = Developer(35, "Javascript");</br>
                                    Developer* pointeur_dev = &dev;</br>
                                    std::cout &lt;&lt; pointeur_dev->job() &lt;&lt; std::endl;</br>
                                    std::cout &lt;&lt; (*pointeur_dev).job() &lt;&lt; std::endl; // Fonctionne aussi (mais presque jamais utilisé)
                                </div>
                            </p>
                        </div>
                        <h3 id="part_A_b">
                            b. Utiliser un pointeur
                        </h3>
                        <div>
                            <p id="part_A_b_1">
                                Modifier la variable pointée, c'est bien. Modifier le pointeur directement, c'est mieux.
                                En effet, <u>bien que cela soit impossible pour les références, on peut modifier plusieurs choses sur le pointeur sans altérer la variable pointée</u>.
                                Par exemple, <span class="important">on peut modifier la variable pointée dans le pointeur, en modifiant l'adresse dans le pointeur</span>.
                                Pour cela, c'est très simple :
                                <div class="code_sample">
                                    int age = 50;</br>
                                    int taille = 180;</br></br>
                                    int* pointeur_vers_age = &age;</br>
                                    std::cout &lt;&lt; "Adresse de la variable : " &lt;&lt; pointeur_vers_age &lt;&lt; ", valeur de la variable : " &lt;&lt; *pointeur_vers_age &lt;&lt; std::endl;</br>
                                    // Affiche une adresse et 50</br></br>
                                    pointeur_vers_age = &taille;</br>
                                    std::cout &lt;&lt; "Adresse de la variable : " &lt;&lt; pointeur_vers_age &lt;&lt; ", valeur de la variable : " &lt;&lt; *pointeur_vers_age &lt;&lt; std::endl;</br>
                                    // Affiche une autre adresse (pas très loin de la première) et 180
                                </div>
                                <u>D'ailleurs, une valeur générale pour les pointeurs est la valeur "0"</u>.
                                <span class="important">Un pointeur de valeur 0 est un pointeur ne pointant vers rien</span>.
                                Par exemple, si vous créez un pointeur qui pointera vers une variable après sa définition, sa valeur doit être de 0 entre la définition du pointeur et l'attribution de la bonne valeur.
                                <span class="important">TOUJOURS assigner 0 aux pointeurs ne pointant vers rien, car, si vous ne le faites pas, des erreurs très problématiques peuvent apparaître</span>.
                            </p>
                            <p id="part_A_b_2">
                                <u>On peut aussi utiliser des opérations arithmétiques sur des pointeurs</u>.
                                Cependant, cela n'est pas conseillé dans toutes les situations.
                                Cependant, <span class="important">une situation sécurisée est assez simple permettant ces opérations est l'utilisation d'itérateurs</span>.
                                Nous avons déjà vu ce terme lors du cours sur les structures de données, <a href="cpp_algorithm_data_structure.html">juste ici</a>.
                                En fait, <span class="important">un itérateur est une sorte de pointeur utilisée dans une structure de donnée, qui pointe vers un élément de la structure</span>.
                                Chaque structures a son propre type d'itérateur, définit dans la classe de la structure en question (par exemple, pour vector, on doit y accéder avec std::vector&lt;Type_Dans_Le_Vecteur&gt;::iterator), avec les mêmes membres que le type <a href="https://cplusplus.com/reference/iterator/iterator/" target="_blank">"iterator"</a>.
                                Cependant, leur utilisation pour les structures simples est complétèment inutile, assez complexe, et déconseillée (c'est comme utiliser les méthodes en moins bien).
                                <u>Il est plus intéressant de les utiliser dans des structures plus complexes, comme dans les map</u>.
                                Par exemple, les itérateurs de map ne pointent pas seulement vers une valeur, mais vers un objet (nommé une <a href="https://cplusplus.com/reference/utility/pair/">pair</a>) contenant la clé et la valeur d'une itération du map à une certaine position (le premier élément ajouté est le premier itérateur, le deuxième est le deuxième itérateur...).
                                <u>C'est là que les opérations arithmétiques rentrent en jeu</u>.
                                Voici un petit exemple d'utilisation d'opérations sur les itérateurs :
                                <div class="code_sample">
                                    // On crée un map, et on le rempli un peu</br>
                                    std::map&lt;std::string, int&gt; age;</br>
                                    age["Lucas"] = 14;</br>
                                    age["Corentin"] = 27;</br>
                                    age["Thierry"] = 56;</br></br>
                                    // On accéde à tous les itérateurs du map en incrémentant un itérateur, et on affiche leur contenu</br>
                                    for(std::map&lt;std::string, int&gt;::iterator it = age.begin();it!=age.end();it++) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Dans un pair de map, "first" représente la clé et "second" la valeur</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; it->first &lt;&lt; " : " &lt;&lt; it->second &lt;&lt; std::endl;</br>
                                    }
                                </div>
                                En effet, on peut le deviner, mais "age.begin()" représente le premier itérateur, "age.begin() + 1" le deuxième, "age.begin() + 2" le troisième...
                                <span class="important">Effectuer une addition avec un pointeur permet d'accéder à l'adresse mémoire juste après celle dans le pointeur</span>.
                                Plus précisément, si le premier pointeur pointe vers un objet de taille X, son addition amène à l'objet X octets après celui là.
                                <u>Donc, dans le cas des itérateurs utilisés dans les structures de données, les itérateurs sont structurés de telle manière que l'addition d'un itérateur amène au prochain itérateur de la structure</u>.
                                Si vous trouvez le fonctionnement interne des itérateurs complexe, ne vous inquiétez pas, cela ne nous servira à rien pour l'instant.
                                Seul l'utilisation externe nous intéresse ici.
                            </p>
                            <p id="part_A_b_3">
                                Avec ces définitions des pointeurs, on peut donc modifier la variable pointée facilement.
                                Cependant, comme nous l'avons vu lors du cours <a href="./cpp_variables.html">sur les variables</a>, <u>certaines variables peuvent être constantes, et ne sont pas modifiables</u>.
                                <u>Il n'est pas possible d'utiliser un simple pointeur pour ces variables</u>.
                                Cependant, <span class="important">nous pouvons définir un pointeur qui pointe vers une variable constante, de cette façon</span> :
                                <div class="code_sample">
                                    // On crée une variable constante et un pointeur vers cette variable en ajoutant "const" avant</br>
                                    const int taille = 180;</br>
                                    const int* pointeur_vers_taille = &taille;
                                </div>
                                Vous pouvez aussi définir un pointeur comme ça, même si la variable pointée n'est pas constante (vous ne pourrez pas la modifier avec le pointeur).
                                Avec cette méthode, <u>nous pouvons toujours modifier l'adresse dans le pointeur comme nous l'avons vu (seul la valeur à l'adresse dans le pointeur n'est pas modifiable)</u>.
                                <span class="important">Si vous voulez rendre les modifications de la variable pointée possible, mais les modifications de l'adresse contenu imposse, il faut changer le "const" de place</span> :
                                <div class="code_sample">
                                    // On crée une variable et un pointeur vers cette variable qui ne pointera jamais autre part que la variable</br>
                                    int taille = 180;</br>
                                    int* const pointeur_vers_taille = &taille;</br></br>
                                    // Vous pouvez aussi combiner les deux (adresse constante et variable pointée constante)</br>
                                    const int* const pointeur_constant_vers_taille = &taille;
                                </div>
                            </p>
                        </div>
                        <h3 id="part_a_c">
                            c. Les dangers des pointeurs
                        </h3>
                        <div>
                            <p id="part_a_c_1">
                                Vous l'aurez peut être deviné, mais les pointeurs peuvent causer des bugs, voir des crashs dans votre programme.
                                <span class="important">Les erreurs de pointeurs sont, en général, appelées les erreurs de segmentation (ou segmantation fault)</span>.
                                <u>L'erreur de segmentation la moins problèmatique est la modification d'une variable via un pointeur pointant vers 0 (donc, ne pointant vers rien)</u>.
                                Cela provoque un simple crash, sans autre incidents inatendus.
                                Un moyen d'éviter cette erreur est de rajouter une comparaison à 0 avant l'utilisation, et d'éviter l'utilisation si la valeur du pointeur est de 0 :
                                <div class="code_sample">
                                    int* pointeur_vers_taille = 0;</br>
                                    if(pointeur_vers_taille == 0) {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Modification impossible" &lt;&lt; std::endl;</br>
                                    }</br>
                                    else {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pointeur_vers_taille = 170;</br>
                                    }</br>
                                </div>
                            </p>
                            <p id="part_a_c_2">
                                Cependant, vous pouvez faire pire avec ces pointeurs.
                                En effet, <u>même si le pointeur n'est pas vide, la variable pointée par le pointeur peut causer des problèmes</u>.
                                <span class="important">Le premier bug possible est d'accéder / modifier à la mauvaise variable</span>.
                                Dans ce cas, deux comportements sont possibles.
                                <u>Si l'adresse pointée est hors des adresses possibles dans le programme, dans les systèmes d'exploitation moderne, le programme plante</u>.
                                Dans les systèmes d'exploitation peut sécuriser, vous pouvez agir comme vous voulez sur cette adresse, bousillant la donnée s'y trouvant (pouvant être une image d'un autre programme, comme votre mot de passe pour le système).
                                Dans l'autre cas, <u>l'adresse pointée est dans les adresses accessibles au programme, bousillant toutes les variables du programme se trouvant là</u>.
                                Avec les syntaxes que nous avons vu, <u>ce cas de figure peut arriver, par exemple, quand le pointeur pointe vers une variable, et que l'on utilise le pointeur hors de la zone de définition de cette variable (donc, quand la variable a été supprimée)</u>.
                                Le pointeur pointe vers cette adresse lorsque qu'elle existait, or, après sa suppression, une autre variable peut remplacer la variable voulu, sans que le pointeur ne le sache.
                                <span class="important">Faites donc bien attention à éviter ce genre d'erreur, surtout que le programme ne plante pas toujours avec ce genre d'erreurs</span>.
                            </p>
                            <p id="part_a_c_3">
                                <u>Une autre erreur possible est une utilisation incontrôlée des types avec les pointeurs</u>.
                                En effet, <span class="important">des pointeurs vers différents types peuvent être interprétés de la même façon par le compiler, créant des erreurs de segmentation avec l'accès au variable</span>.
                                Cependant, pour qu'une erreur de ce genre arrive, il faut pouvoir convertir un pointeur pointant vers un type en un pointeur convertissant vers un autre type, ce qui n'est pas nécessaire pour l'instant.
                                <u>Le risque peut en valoir le coût dans certains cas, lorsque l'on veut stocker une adresse mémoire d'une variable, sans connaître son type précis</u>.
                                En général, on crée une classe parent, qui servira de type pour stocker les variables, qui sera la base de classes, utilisant la technique d'abstraction pour fonctionner de manière plus spécialisé.
                                Cependant, quand ce n'est pas possible, il faut recourir à une conversion, pour utiliser la variable avec un type spécifique, via les pointeurs.
                                Reprenons l'exemple des classes "Person" et "Developer", vu au cours sur <a href="./cpp_class.html">les classes et objets</a>.
                                Imagineons une methode "std::string language()" pour "Developer", qui retourne le language utilisé par le développeur, mais inutilisable dans "Person".
                                Réalisons une conversion :
                                <div class="code_sample">
                                    // Création d'un développeur</br>
                                    Person dev = Developer(34, "C"); // Possible selon le principe de polymorphisme, vu au derniers cours</br>
                                    Person* person = &dev;</br></br>
                                    // On réinterprète le pointeur "Person" vers un pointeur de "Developer" avec "reinterpret_cast"</br>
                                    // Non-problématique car le pointeur pointe vers une variable crée avec "Developer"</br>
                                    Developer* dev_pointeur = reinterpret_cast&lt;Developer*&gt;(person);</br>
                                    std::cout &lt;&lt; dev_pointeur->language() &lt;&lt; std::endl;
                                </div>
                                Bon, dans ce cas là, la conversion est complètement inutile, puisque l'on peut directement crée le "Developer" dans une variable déclaré "Developer", au lieu de s'embêter à faire ça.
                                Cependant, si nous n'avons accès qu'à une version de "Developer" (ou de n'import quelle autre objet) via une adresse de pointeur "Person*", cette technique fonctionne.
                                <span class="important">Cependant, faites bien attention de ne pas vous tromper de type, pour ne pas provoquer d'erreurs</span>.
                                D'ailleurs, <u>un pointeur ne pointant vers aucun type (mais contenant quand même une adresse de n'importe quel type) est un pointeur de type "void*", ou la conversion est obligatoire pour l'utilisation (à utiliser avec précaution)</u>.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        B. Les mémoires "stack" et "heap"
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <h3 id="part_B_a">
                            a. Qu'est ce que sont les mémoires "stack" et "heap" ?
                        </h3>
                        <div>
                            <p id="part_B_a_1">
                                Le compiler est un outil particulièrement complexe, tellement qu'il nous permet de définir toutes les variables que l'on veut sans problème.
                                Pour comprendre cette partie, nous allons le décortiquer, grâce à <a href="https://godbolt.org/">Compiler Explorer</a>.
                                Prenons un très simple code, comme :
                                <div class="code_sample">
                                    int main() {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char variable_1[128];</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int variable_2 = 8;</br></br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    }</br>
                                </div>
                                Laissons ce code être converti en assembleur.
                                Ici, 4 lignes d'assembleur nous intéressent :
                                <div class="code_sample">
                                    push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rbp</br>
                                    mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rbp, rsp</br>
                                    sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rsp, 24</br>
                                    mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD PTR [rbp-4], 8
                                </div>
                                Pour comprendre ce que l'on doit comprendre, il va falloir vulgariser, parce que nous ne sommes pas dans un cours d'assembleur.
                                La première ligne permet d'utiliser la mémoire facilement dans la fonction main, via le mot clé "rbp".
                                En fait, <u>"rbp" représente un moyen d'accéder à la mémoire que la fonction va utiliser</u>.
                                Cependant, si l'on crée une autre fonction, on se rend compte que "rbp" est aussi utilisé dans cette fonction.
                                En fait, <span class="important">le système d'exploitation va permettre à tout le programme d'utiliser une même partie de la mémoire, accessible via "rbp"</span>.
                                D'ailleurs, l'instruction "mov" est l'instruction responsable de l'attribution de la variable "variable_2", via "rbp" ("variable_1" est aussi définie, mais comme aucune valeur ne lui est attribuée, alors pas besoin de "mov", juste d'augmenter le nombre après "sub").
                                <u>Cette mémoire a une taille fixe, défini grâce à l'instruction "sub" du code assembleur</u>.
                                La taille précise de la mémoire est de 128 octets, au quel on additionne le nombre d'octets après l'instruction "sub" (un peu plus que le nombre d'octets nécessaire au programme, pour éviter les bugs).
                                Calculer la taille précise de la mémoire utilisable ici est une perte de temps (et un exercice extrêmement complexe, à cause de la volatilité du language assembleur), <u>puisque ce qui nous intéresse c'est le terme de fixe</u>.
                                <span class="important">Cette mémoire fixe utilisable partout dans le programme est nommé la mémoire "stack" (stack pour "pile", car les données sont empilées dans le programme)</span>.
                                <u>Sa taille et son contenu sont définis pendant la compilation (si vous rajoutez une variable dans le code, la prochaine compilation va le prendre en compte, et redéfinir la taille fixe)</u>.
                            </p>
                            <p id="part_B_a_2">
                                Maintenant, <u>imagineons que nous voulons rajouter des variables dans la mémoire, pendant l'exécution du programme (comme ajouter un élement à une liste)</u>.
                                Avec cette définition de la mémoire stack, <span class="important">on ne peut pas rajouter cette variable dans la mémoire stack, car sa taille est fixe</span>.
                                Heuresement, <u>il existe un autre type de mémoire, utilisable librement, sans contrainte de mémoire fixe</u>.
                                Pour cela, <span class="important">il faut accéder à une mémoire, nommée la mémoire "heap" (tas en français)</span>.
                                Cependant, elle n'est pas dans la mémoire définie spécialement dans le programme, <u>donc on ne pourra pas y accéder via "rbp"</u>.
                                <u>On ne pourra y accéder que via son adresse mémoire</u>.
                                Nous n'allons pas voir d'exemples en Assembleur, car il nous seront inutile ici.
                            </p> 
                        </div>
                        <h3 id="part_B_b">
                            b. Utiliser le heap en C++
                        </h3>
                        <div>
                            <p id="part_B_b_1">
                                Pour créer une variable dans le "heap" en C++, <span class="important">il faut utiliser un constructeur primaire du C++ : le constructeur "new", qu'il faut spécifier avant le type a créer</span>.
                                <u>Ce constructeur retourne l'adresse mémoire de l'espace crée dans le "heap", stockable dans un simple pointeur</u>.
                                Voici un exemple d'utilisation :
                                <div class="code_sample">
                                    int* pointeur = new int(8);
                                </div>
                                Il faut obligatoirement utiliser l'assignation avec la technique du "= type(parametre)" pour utiliser new.
                                Grâce à ça, <u>nous pouvons commencer à manipuler des variables dans le "heap" en C++</u>.
                                D'ailleurs, c'est la technique utiliser dans les vecteurs pour rajouter des élements.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/aster-school" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>
