<!DOCTYPE html>
<html lang="fr">
    <head>
        <link href="../../styles/base.css" rel="stylesheet" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SAASF - Hub</title>

        <!--Connect to google font-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!--Get the Hammersmith One font, see https://fonts.google.com/specimen/Hammersmith+One for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Hammersmith+One&display=swap" rel="stylesheet">
        <!--Get the OpenSans font, see https://fonts.google.com/specimen/Open+Sans for more informations-->
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
    </head>
    <body class="open-sans-bold">
        <header class="hammersmith-one-regular">
            <img alt="Logo de SAASF" src="../../images/logo.png"/>
            <nav>
                <div>
                    <a>
                        Lycée
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
                <div>
                    <a>
                        Aster Système Learn
                        <img alt="Défiler" src="../../images/arrow.png" style="transform: rotate(90deg);height: 0.6em;">
                    </a>
                </div>
            </nav>
        </header>
        <div id="main_div">
            <h1>
                II - 1. Organiser un projet en C++
            </h1>
            <div>
                Si vous vous rappelez, le premier cours de cette série comprenait une partie similaire à ce qui va être exposé là.
                Cependant, on ne faisait que froller les manières de configurer un projet en C++.
                Dans ce cours, on va rentrer plus en détail, pour comprendre, et de nouvelles choses, et des choses qu'on a déjà vu, mais survolé dans les précédents cours.
            </div>
            <div class="left_arrow_right_text">
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_A">
                        A. Organiser son projet
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Le C++ offre plein de fonctionnalités permettant de configurer proprement votre projet C++.
                        <h3 id="part_A_a">
                            a. Les fichiers headers / sources
                        </h3>
                        <div>
                            <p>
                                Pour l'instant, notre code est écrit dans un fichier avec l'extension ".cpp".
                                <span class="important">Ces fichiers sont des fichiers sources C++, ceux que le compiler va compiler en fichiers objets en ".o"</span>.
                                <u>Pour rappel, le code objet est constitué <a href="https://fr.wikipedia.org/wiki/Assembleur">d'assembleur</a></u>.
                                Plus les fichiers ".cpp" sont remplies, plus la compilation est longue.
                                <u>On peut mettre autant de fichier ".cpp" dans notre projet que l'on veut</u>.
                                Cependant, dans ce cas, <u>pour utiliser du code présent dans un autre fichier, il faut inclure le code du fichier à utiliser dans le fichier de base</u>.
                                <span class="important">En C++, ce processus ce fait via une prédirective : "#include" (voir plus bas)</span>.
                            </p>
                            <p>
                                Cependant, imaginons un projet avec 150 fichiers en ".cpp" (ce qui est possible, si votre projet est un minimum ambitieux).
                                La modification d'un seul fichier demande de recompiler tout le gros bloc de 150 fichiers, vous laissant le temps de courir un marathon entre deux compilations.
                                Heuresement, <u>il existe un moyen d'utiliser un fichier ".cpp", sans avoir à le recompiler à chaque fois : les fichiers headers en ".h"</u>.
                                <span class="important">Un fichier header permet de déclarer quelque chose dans un code, sans avoir à le redéfinir, donc à le re-compiler (si il est déjà défini / compiler quelque part)</span>.
                                <u>Dans le fichier exécutable final, produit par le linker, le linker lie les déclarations de chaque fichier objet à leur définition déjà compilé</u>.
                                Si la définition de quelque chose déclaré n'est pas trouvé, le linker renvoie une erreur "undefined reference to `truc_pas_defini'".
                                Un header peut contenir toutes les déclarations possibles et imagineables : variables, fonctions...
                                Dans ce cas, la déclaration est réalisé via ce que l'on appelle un "lien externe" ("extern linkage" en anglais).
                                En général, il est très fortement conseillé (voir obligatoire dans certains cas) de rajouter le mot clé "extern" devant la déclaration.
                                <span class="important">Chaque fichier ".cpp" doit inclure le header contenant ses déclarations</span>.
                            </p>
                            <p>
                                <span class="important">Il est important de noter que les fichiers headers peuvent aussi contenir des définitions</span>.
                                <u>Cependant, dans ce cas là, le même problème qu'avec nos 150 fichiers ".cpp" apparaît</u>.
                                De plus, le linker pourraît se perdre dans les multiples couples déclarations / définitions possibles, causant d'étranges erreurs de linker.
                                Dans ce cas là, la déclaration est réalisé via ce que l'on appelle un "lien interne" ("internal linkage" en anglais).
                                <span class="important">Un moyen d'éviter les erreurs est de définir la déclaration du header de manière statique, en rajoutant le mot clé "static" avant elle</span>.
                                Avec cela, on garde notre problème des 150 fichiers ".cpp", car chaque fichier objet à sa propre copie de la définition, évitant les erreurs.
                            </p>
                            <p>
                                <span class="important">Un fichier header doit toujours avoir cette forme :</span>
                                <div class="code_sample">
                                    #ifndef NOM_DU_FICHER</br>
                                    #define NOM_DU_FICHER</br></br>
                                    // Trucs dans le header</br></br>
                                    #endif NOM_DU_FICHER
                                </div>
                                Nous verrons pourquoi dans la partie sur les prédirectives.
                            </p>
                        </div>
                        <h3 id="part_A_b">
                            b. Configurer le compiler / linker
                        </h3>
                        <div>
                            <p>
                                Pour compiler correctement votre code, <u>il vous faut comprendre comment configurer le compiler et le linker</u>.
                                <span class="important">En général, tous les IDEs offrent une GUI pour les configurer</span>.
                                Sinon, une simple recherche Google devrait vous guider.
                                <u>Sans IDE, le compiler et le linker doivent s'utiliser entièrement grâce aux lignes de commandes</u>.
                                L'IDE se charge de passer les bons arguments au compiler.
                            </p>
                            <p>
                                La première tâche est de choisir le bon duo cimpler / linker à utiliser.
                                <span class="important">Dans le cas général (l'environnement <a href="https://www.mingw-w64.org/" target="_blank">MinGW</a>), tout ce qui est nécessaire à la compilation se trouve dans un même dossier</span>.
                                De base, tout le nécessaire est présent sous Linux, de manière différente selon la distribution.
                                Cependant, si vous ne l'avez pas encore d'installer, sachez que l'installer comme tel est assez déconseillé.
                                <u>Il est fortement conseillé de passer par un environnement Linux, ou un émulateur d'environnement Linux si vous êtes sur Windows, comme <a href="https://www.msys2.org/" target="_blank">MSYS2</a> ou <a href="https://cygwin.com/" target="_blank">Cygwin</a></u>.
                                Microsoft proporese un petit tutoriel, <a href="https://code.visualstudio.com/docs/languages/cpp" target="_blank">juste ici</a>, pour l'installer avec MSYS2 (seule la partie MSYS2 nous intéresse ici).
                                <span class="important">Dés que vous avez repérer le dossier le plus haut de votre MinGW, vous avez juste à le passer à l'IDE, qui fera la suite lui même</span>.
                                <u>Si son chemin d'accès de ce dossier est ajoutée à la variable d'environnement "Path", alors l'IDE pourra le détécter automatiquement</u>.
                            </p>
                            <p>
                                Ce dossier contient plusieurs sous-dossiers, que nous allons survoler, pour comprendre un peu mieux le tout.
                                <span class="important">Le sous dossier "bin" contient tous les logiciels nécessaires à la compilation, comme le compiler</span>.
                                <u>Le compiler C++ représente le logiciel "g++.exe", mais un compiler C est aussi fourni, sous le nom de "gcc.exe"</u>.
                                Un compiler C++, spécialisé pour le debug, est aussi fourni : "gdb.exe".
                                <span class="important">Un autre sous dossier important "include", qui contient tous les morceaux de codes que l'on pourra utiliser via "#include" (voir plus bas), sans avoir à fournir le chemin d'accès complet</span>.
                                <u>Vous pouvez aller fouiller dedans si vous voulez, pour voir certains codes</u>, comme "string.h" pour &lt;string&gt;, ou bien "math.h" pour &lt;math&gt;.
                                <span class="important">Le dernier sous dossier est "lib", contenant tous les fichiers ".cpp" compilés nécessaires, pour faire marcher votre programme C++</span>.
                                En effet, les "#include" sont exclusivement des fichiers headers, mais leur partie compilé est présente, sous la forme de librairie.
                                <u>Une librairie, d'extension ".a", ".so" ou ".lib" selon la plateforme, représente un ensemble de fichiers ".cpp" déjà compilés</u>.
                                Ils permettent donc de ne pas avoir à recompiler tous les "#include" utilisés.
                            </p>
                            <p>
                                <span class="important">Certains des arguments optionnels sont très importants, donc, voici une liste non-exhaustive de certains d'entre eux</span> :
                                <ul>
                                    <li>
                                        <u>Le C++ se décline en plusieurs versions différents, et la version précise à spécifier peut l'être grâce à un argument vers le compiler C++ : "-std"</u>.
                                        Si "-std" est "c++20", on utilise la version 20 du C++ (normalisée par l'ISO en 2020).
                                        Si "-std" est "c++98", on utilise la version 98 du C++ (normalisée par l'ISO en 1998).
                                    </li>
                                    <li>
                                        <u>Le C se décline en plusieurs versions différents (si vous devez utiliser du C à un moment dans votre projet), et la version précise à spécifier peut l'être grâce à un argument vers le compiler C : "-std"</u>.
                                        Si "-std" est "c17", on utilise la version 20 du C (normalisée par l'ISO en 2017).
                                        Si "-std" est "c90", on utilise la version 98 du C (normalisée par l'ISO en 1990).
                                    </li>
                                    <li>
                                        <u>Vous pouvez aussi passer aux compiler des arguments, de catégorie "#define", utilisables via les directives (voir plus bas)</u>.
                                    </li>
                                </ul>
                                <u>Deux ensembles de configurations possibles, réglables dans l'IDE, sont les configurations "Debug" et "Release"</u>.
                                <span class="important">La configuration "Debug" permet d'utiliser un outil, nommé le débugueur, pour traquer les potentielles bugs du code</span>.
                                Cependant, elle est moins performante et plus longue à compiler.
                                <span class="important">La configuration "Release" permet de compiler normalement le code, sans possibilité de traquer les potentielles bugs</span>.
                                <u>Cette configuration est nécessaire pour partager un logiciel compiler à autrui</u>.
                                Cependant, pour pouvoir être utilisable hors de votre environnement, <span class="important">il faut rajouter dans le même dossier que l'exécuteur des morceaux de codes spéciaux, nommés les DLLs</span>.
                                <u>Les DLLs primaires en C++ sont présents dans le dossier "bin" du compiler, et sont les DLLs "libstdc++", "libwinpthread-1" et "libgcc_s_seh-1"</u>.
                            </p>
                        </div>
                        <h3 id="part_A_c">
                            c. Ajouter des dépendances externes
                        </h3>
                        <div>
                            <p>
                                Le code inclut dans l'environnement, c'est bien.
                                <u>Les codes plus complexes, c'est mieux</u>.
                                <span class="important">Pour télécharger du code provenant d'un autre endroit que de l'environnement, il y a pas mal de choses à faire</span>.
                            </p>
                            <p>
                                <span class="important">Si vous téléchargez le code source à rajouter directement sous forme de fichiers ".cpp" et ".h", il vous faudra le compiler vous même une fois, pour le transformer en librairie</span>.
                                Pour cela, <u>il y a plusieurs outils différents utilisables</u>.
                                <span class="important">L'un d'eux est <a href="https://cmake.org/download/">CMake</a>, permettant de configurer un projet C++</span>, pour pouvoir le compiler après normalement, via un IDE, ou directement à même le compiler.
                                <u>Les codes sources utilisant CMake contiennent des fichiers "CMakeList.txt"</u>.
                                <span class="important">Une autre méthode plus répandu est la compilation via l'outil "Make"</span>.
                                Pour cela, <u>il faut utiliser dans le même terminal que celui avec lequel vous avez installer votre compiler (MSYS, Cygwin...) la commande "make" avec comme argument le dossier vers le code source</u>.
                                Avant cela, <u>il est conseillé d'effectuer la commande "./configure" pour configurer "make"</u>.
                            </p>
                            <p>
                                <span class="important">Si vous trouvez le code directement pré-compilé dans une librairie, alors pas besoin de le compiler vous même</span>.
                                Cependant, pour pouvoir pleinement l'utiliser, <u>il y a encore quelques petites choses à faire</u>.
                                Actuellement, vous devriez avoir les headers et le code pré-compilé.
                                <span class="important">Pour pouvoir utiliser les headers, nous allons prendre une technique simple, et simplement les placer dans le sous-dossier "include" de votre compiler</span>.
                                Comme ça, un simple appel comme &lt;iostream&gt; suffit.
                                Il est conseillé de les mettre dans un dossier dans le dossier include, pour les retrouver plus rapidement.
                                Pour les codes pré-compilés, on va faire la même chose, et simplement les placer dans le sous-dossier "lib" de votre compiler</span>.
                                Pour pouvoir les inclure au projet, <u>vous devez aller dans les paramètres du linker, et rajouter le chemin d'accès du code pré-compilé à utiliser dans la section "Librairies liées"</u>.
                                <span class="important">Certaines librairies peuvent produire ou demander des DLLs, que vous devez juste inclure dans le dossier de l'éxecuteur</span>.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_B">
                        B. Organiser le code de son projet
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        Certaines modifications textuelles du code permettent de configurer le projet, de manière plus étendue qu'on ne le pense.
                        <h3 id="part_B_a">
                            a. Utiliser les prédirectives
                        </h3>
                        <div>
                            <p id="part_B_a_1">
                                Bien que ce nom puisse faire un peu peur, <a href="https://cplusplus.com/doc/tutorial/preprocessor/" target="_blank">les prédirectives</a> sont assez simples d'utilisation.
                                <span class="important">Il s'agit de morceau de texte dans le code, permettant au compiler de modifier le code avant la compilation</span>.
                                <u>Elles permettent de rendre le code plus portatifs, par exemple en permettant au compiler de ne pas compiler une certaine partie de code si il ne peut pas</u>.
                                <span class="important">Elles fonctionnent de manière entièrement textuel, et ne sont pas considérées comme des instructions</span>.
                                Elles ne finissent pas par un ";", mais lors du saut de ligne.
                                <u>Toutes les prédirectives en C++ commence par le symbole "#"</u>.
                            </p>
                            <p id="part_B_a_2">
                                Nous avons déjà utilisés à plusieurs reprises une prédirectives : "#include".
                                <span class="important">La prédirective "#include" permet, comme nous l'avons déjà vu, d'inclure un morceau de code dans un autre morceau de code</span>.
                                Pour être plus précis, <u>le morceau de code à inclure remplace la ligne de prédirective dans le fichier de base</u>.
                                Voici deux utilisation simples de la prédirective :
                                <div class="code_sample">
                                    #include &lt;iostream&gt;</br>
                                    #include "scls.h"
                                </div>
                                <u>En général, il est conseillé de n'inclure que des fichiers headers</u>, pour ne pas surcharger le code.
                                Cette prédirective permet d'inclure tous les fichiers que vous voulez.
                                <u>Si le chemin d'accés du fichier est entouré de chevrons (comme iostream), le fichier se trouve dans des fichiers inclus au compiler.
                                Si le chemin d'accés est entouré de guillemets, il se trouve autre part (n'importe où dans le système), relativement au fichier de base.</u>
                            </p>
                            <p id="part_B_a_3">
                                Si un morceau de code est inclut plusieurs fois, par exemple, dans deux autres morceaux de code différents, des conflits peuvent apparaître.
                                <u>Pour éviter cela, il faut utiliser trois autres prédirectives, dont "#define"</u>.
                                <span class="important">"#define" permet de définir un morceau de texte, nommé une macro</span>.
                                <u>Une macro est un morceau de texte, utilisable par un nom, qui, si écrit (le nom) quelque part dans le code, est remplacé par le morceau de texte de la macro</u>.
                                Voici un exemple de définition et d'usage d'une macro :
                                <div class="code_sample">
                                    #include &lt;iostream&gt;</br>
                                    #define VERSION "1.5"</br></br>
                                    using namespace std;</br></br>
                                    int main()</br>
                                    {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// VERSION est remplacé par "1.5" avant la compilation</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Version du logiciel : " &lt;&lt; VERSION &lt;&lt; endl; // Affiche "Version du logiciel : 1.5"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    }
                                </div>
                                Cette prédirective est très utile pour utiliser des valeurs constantes, sans avoir à s'encombrer de variables constantes.
                                En général, elles sont nommées avec des majuscules.
                                <u>Il existe quelques macros pré-définies en C++</u>, comme "__LINE__" qui est remplacée par le numéro de la ligne actuelle (les autres sont documentées <a href="https://cplusplus.com/doc/tutorial/preprocessor/#predefined_macro_names" target="_blank">ici</a>).
                            </p>
                            <p id="part_B_a_4">
                                Si un morceau de code est inclut plusieurs fois, par exemple, dans deux autres morceaux de code différents, des conflits peuvent apparaître.
                                <u>Pour éviter cela, il faut utiliser trois autres prédirectives, dont "#define"</u>.
                                <span class="important">"#define" permet de définir un morceau de texte, nommé une macro</span>.
                                <u>Une macro est un morceau de texte, utilisable par un nom, qui, si écrit (le nom) quelque part dans le code, est remplacé par le morceau de texte de la macro</u>.
                                Voici un exemple de définition et d'usage d'une macro :
                                <div class="code_sample">
                                    #include &lt;iostream&gt;</br>
                                    #define VERSION "1.5"</br></br>
                                    using namespace std;</br></br>
                                    int main()</br>
                                    {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// VERSION est remplacé par "1.5" avant la compilation</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Version du logiciel : " &lt;&lt; VERSION &lt;&lt; endl; // Affiche "Version du logiciel : 1.5"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    }
                                </div>
                                Cette prédirective est très utile pour utiliser des valeurs constantes, sans avoir à s'encombrer de variables constantes.
                                <span class="important">Vous pouvez même les supprimer, avec la prédirective "#undef NOM_DE_LA_MACRO", pour libérer le nom de la macro pour plus tard si besoin</span>.
                                En général, elles sont nommées avec des majuscules.
                                <u>Il existe quelques macros pré-définies en C++</u>, comme "__LINE__" qui est remplacée par le numéro de la ligne actuelle (les autres sont documentées <a href="https://cplusplus.com/doc/tutorial/preprocessor/#predefined_macro_names" target="_blank">ici</a>).
                                <span class="important">Vous pouvez aussi utiliser des parenthèses pour customiser la macro selon vos besoins, avec des valeurs spécifiques</span>, comme par exemple :
                                <div class="code_sample">
                                    #include &lt;iostream&gt;</br>
                                    #define VERSION_FINALE(version, sous_version) (string(version) + "." + sous_version)</br>
                                    // L'utilisation de la fonction "string" pour "version" est nécessaire, car on ne peut pas additionner</br>
                                    // deux chaînes de caractères sans en convertir au moins une en "string"</br></br>
                                    using namespace std;</br></br>
                                    int main()</br>
                                    {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// VERSION_FINALE("1", "5") est remplacé par "1.5" avant la compilation</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "Version du logiciel : " &lt;&lt; VERSION_FINALE("1", "5") &lt;&lt; endl; // Affiche "Version du logiciel : 1.5"</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    }
                                </div>
                            </p>
                            <p id="part_B_a_5">
                                Pour l'instant, toutes les prédirectives que nous avons vu sont que statique, et ne peuvent modifient pas le code selon une condition.
                                <u>Cependant, il en existe d'autres pouvant le faire, de la même manière que "if", "else if" et "else"</u>.
                                <span class="important">Ces prédirectives sont nommées prédirectives de conditions et sont sous la forme "#ifdef", "ifndef", "#if", "#else", "#elif" et "#endif"</span>.
                                <span class="important">"#if" permet de ne pouvoir compiler un morceau de code que si une certaine condition est définie (implicant des macros), en sachant que sa syntaxe d'utilisation est la même que pour "if(condition)"</span>.
                                <u>Elle peut être couplée avec "#elif" (else if(condition)) ou "#else" pour être rendue plus complète</u>.
                                <span class="important">À la fin du morceau de code dans le "#if", il faut spécifier que l'on ferme la condition, avec "#endif"</span>.
                                "#ifdef" est une version avancée de "#if".
                                <u>En effet, elle est considérée comme "vraie" si une macro, spécifiée juste après, est définie avec "#define" ou via les "#defines" du compiler ou non</u>.
                                <u>À l'inverse, "ifndef" permet de savoir si une macro n'est pas définie</u>.
                                Un exemple d'utilisation de tout ça est le contenu obligatoire des fichiers headers.
                                Un exercice que vous pouvez faire, et d'essayer de comprendre pourquoi leur structure est définie comme ça :
                                <div class="code_sample">
                                    #ifndef NOM_DU_FICHER</br>
                                    #define NOM_DU_FICHER</br></br>
                                    // Trucs dans le header</br></br>
                                    #endif NOM_DU_FICHER
                                </div>
                                En tout cas, voici la réponse.
                                Pour rappel, <u>les headers sont inclus via "#include", copiant juste leur contenu dans le fichier dans lequel ils sont inclus</u>.
                                Cependant, si plusieurs fichiers appellent un même header, sont contenu est copié plusieurs fois, ce qui est inutile.
                                Pour cela, <u>à chaque copie, on regarde si la macro "NOM_DU_FICHIER" a été définie</u>.
                                À la première copie, <u>la macro n'est pas encore définie, on peut la définir</u>.
                                Lors de tous les prochains "#include", la macro ayant déjà été définie, la copie ne se fera pas inutilement, optimisant le code à compiler.
                                <span class="important">Cette technique est surtout utilisée pour permettre de ne pas compiler un morceau de code incompatible sur un certain environnement, sans avoir à le supprimer entièrement du code</span>.
                                Par exemple, <u>si vous utilisez une fonction Windows qui n'est pas utilisable sur Linux, sa compilation sur Linux va retourner une erreur</u>.
                                <u>En utilisant une prédirective conditionnelle, comme "#ifdef _WIN32", vous pouvez savoir si le code est compilé sur un environnement Windows</u> ("_WIN32" est une macro pré-définie pour dire si l'on se trouve dans un environnement Windows, minimum 32-bits).
                                La macro pré-définie pour Linux est "__linux__".
                            </p>
                            <p id="part_B_a_6">
                                Pour en finir avec les prédirectives, nous allons voir les prédirectives un peu moins importantes que celles déjà vues.
                                <span class="important">La prédirective "#error Texte a afficher au compiler" permet de créer une erreur de compilation</span>.
                                Elle est faite pour être utilisée avec les "#if" et ses homologues, <u>par exemple si un code ne doit pas être compilé sur un certain système</u>.
                                <span class="important">La prédirective "#pragma parametre valeur" permet de spécifier un paramètre et sa valeur au compiler</span>.
                                Les paramètres dépendent du compiler utilisé.
                                <span class="important">Finalement, la prédirective "#line numero_de_ligne texte" permet de spécifier le fonctionnement d'une ligne de code, en vu d'une possible erreur</span>.
                            </p>
                        </div>
                        <h3 id="part_B_b">
                            b. Utiliser les espaces de noms
                        </h3>
                        <div>
                            <p id="part_B_b_1">
                                Pour l'instant, parmis tous les codes que nous avons fait jusque ici, une seule ligne nous reste inexpliquée : "using namespace std;".
                                <u>Pourtant, c'est celle qui nous permet d'utiliser tous les codes que nous avons "#include" facilement</u>.
                                <span class="important">En effet, tous ces codes primaires aux C++ (string, iostream, math...) sont contenus dans ce que l'on appelle un espace de nom, nommé "std"</span>.
                                <u>Pour accéder à une chose contenu dans un espace de nom, il faut utiliser l'opérateur d'accès à un certain espace, s'écrivant "::", sur l'espace de nom en question.</u>
                                Dans le cas de string et iostream, il faudrai faire comme ça :
                                <div class="code_sample">
                                    #include &lt;iostream&gt;</br>
                                    #include &lt;string&gt;</br></br>
                                    int main()</br>
                                    {</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string nom = "Thomas";</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; "Nom de l'utilsiateur : " &lt;&lt; nom &lt;&lt; std::endl;</br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    }
                                </div>
                            </p>
                            <p id="part_B_b_2">
                                Cependant, pourquoi ne pas l'avoir utilisé plus tôt ?
                                <span class="important">Pour une raison simple : l'utilisation du mot clé "using namespace" permet d'utiliser un espace de nom sans avoir à utiliser l'opérateur "::"</span>.
                                L'avantage est de ne pas avoir à noter "std::" à chaque fois.
                                <u>L'inconvénient est qu'il nous sera impossible d'écrire quelque avec le même nom que les fonctions déjà dans l'espace de nom "std"</u>, comme "string" ou "cout".
                            </p>
                            <p id="part_B_b_3">
                                La création d'un espace de nom en C++ est très simple.
                                <span class="important">Pour créer un espace de nom, il faut simplement utiliser le mot clé "namespace" (sans "using" ici), et en mettant le contenu entre accolades</span>.
                                À noter qu'il est possible de déclarer des choses dans le headers dans un espace de nom, et de les définir dans un fichier source dans le même espace de nom, en réutilisant "namespace".
                                Voici un exemple, pour un fichier header et source de gestion d'utilisateur :
                                <div class="code_sample">
                                    // gestion_utilisateur.h</br></br>
                                    #ifndef GESTION_UTILISATEUR</br>
                                    #define GESTION_UTILISATEUR</br></br>
                                    #include &lt;iostream&gt;</br>
                                    #include &lt;string&gt;</br>
                                    #include &lt;vector&gt;</br></br>
                                    namespace gestion_utilisateur {</br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern std::vector&lt;std::string&gt; utilisateurs;</br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nombre_utilisateurs();</br>
                                    }</br></br>
                                    #endif // GESTION_UTILISATEUR
                                </div>
                                <div class="code_sample">
                                    // gestion_utilisateur.cpp</br></br>
                                    #include "gestion_utilisateur.h"</br>
                                    // Pas besoin d'inclure le reste, ils le sont déjà dans le header</br></br>
                                    namespace gestion_utilisateur {</br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::string&gt; utilisateurs = std::vector&lt;std::string&gt;();</br></br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int nombre_utilisateurs() {</br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return utilisateurs.size();</br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</br>
                                    }
                                </div>
                                <div class="code_sample">
                                    // main.cpp</br></br>
                                    #include "gestion_utilisateur.h"</br></br>
                                    int main() {</br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout &lt;&lt; gestion_utilisateur::nombre_utilisateurs(); // Affiche 0</br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</br>
                                    }
                                </div>
                                Avec cela, organiser correctement votre code devient plus facile que jamais.
                            </p>
                        </div>
                        <h3 id="part_B_c">
                            c. Déboguer son code
                        </h3>
                        <div>
                            <p id="part_B_c_1">
                                Pour finir avec cette partie, nous allons voir quelques manières de facilement déboguer son code, si besoin.
                                <span class="important">Si votre code crash sans savoir pourquoi, une bonne chose à faire est d'utiliser un outil nommé le débogeur</span>.
                                <u>Pour cela, il faut compiler votre code avec la configuration "Debug" (comme vu plus haut), et lancer le code via le débogeur</u>.
                                Le débogueur est capable de vous dire précisément <u>quel ligne à fait planter votre code, quelles fonctions ont appelées la fonction de cette ligne</u>, les threads du crash...
                                En contre partie, le code est un peu plus long à compiler, et moins efficace lors de son éxécution.
                            </p>
                            <p id="part_B_c_2">
                                Un autre moyen de faire est de <span class="important">traquer les données qui peuvent potentiellement provoquer un crash, ou un comportement inattendu, via une succession de "std::cout"</span>.
                                Pour cela, <u>l'idée est d'afficher les données concernées, d'inspecter leur valeur, et de les analyser pour voir si elles ont une part de responsabilité dans le crash</u>.
                                Vous pouvez aussi utiliser cette technique via une itération de boucle / fonction, pour voir quel itération provoque le crash, et qu'elle est sa part de responsabilité.
                                <span class="important">Mettez en où vous pouvez, dans une structure de condition si nécessaire, pour rendre le déboguage le plus efficace possible</span>.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="left_arrow_right_text_child">
                    <img alt="Contenu" class="arrow left_arrow_right_text_arrow" src="../../images/arrow.png">
                    <h2 class="left_arrow_right_text_title" id="part_C">
                        Un petit truc en plus
                    </h2>
                    <div class="left_arrow_right_text left_arrow_right_text_text">
                        <p>
                            Pour en finir avec cette partie du cours, je vais vous présenter en vrac des choses qu'il faut faire, mais que je ne savais pas où mettre précisément.
                        </p>
                        <p>
                            La première chose : <span class="important">écrivez votre code en anglais</span>.
                            En effet, c'est la langue internationalement acceptée pour coder.
                            <u>Cela vous permettra d'être potentiellement aidé, si vous avez besoin d'aide, par n'importe qui sur Terre</u>.
                            Beaucoup de forums de ce genre existent, comme <a href="https://stackoverflow.com/" target="_blank">Stack Overflow</a>.
                            Vous pourrez aussi plus facilement stocker et partager votre code, via par exemple le cloud de <a href="https://github.com/" target="_blank">Github</a>.
                            Dans ce cas là, <u>il vous faut aussi comprendre comment fonctionnent les licences, pour ne pas vous faire juridiquement avoir</u>.
                        </p>
                        <p>
                            La deuxième chose : <span class="important">pensez à documenter votre code pendant la réalisation</span>.
                            Sinon, vous risquez de vous perdre, et de perdre un précieux temps de réalisation.
                            <u>Le minimum est de commenter le code</u>, pour comprendre ce qu'il fait.
                        </p>
                        <p>
                            Après tout cela, nous pourrons entrer dans du C++, un peu plus complexe.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <footer>
            <h1>Plus d'informations</h1>
            <div class="open-sans-regular">
                SAASF est proposé par l'organisation <a href="https://aster-system.github.io/aster-system/" target="_blank">Aster Système</a>.</br>
                Le site web est disponible sur Github, <a href="https://github.com/aster-system/aster-school" target="_blank">dans ce repositorie</a>.</br>
                <span xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">
                    <a property="dct:title" rel="cc:attributionURL" href="https://aster-system.github.io/saasf/">SAASF</a> par <span property="cc:attributionName">Aster Système</span> est proposé sous license <a href="https://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a>
                </span>
            </div>
        </footer>
    </body>
</html>
